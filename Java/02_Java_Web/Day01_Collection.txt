Single column:
Collection: Single column collection root interface
----| List: ordered, repeated
  --------| ArrayList: based on Object instance array, find fast(memory address is continuous), add and delete slow(copy all)
  --------| Vector: based on Object instance array, but thread-safe
  --------| LinkedList: based on linked list, find slow, add and delete fast
----| Set: unordered, unrepeated
  --------| HashSet: based on hash table, store and get fast
              hashCode() and equals()
              When adding elements into HashSet, call hashCode() at first to get the hash code value,
              then compute the location of elements according to hash code value;
              If the location computed has not existed any elements, add it into hash table directly
              If the location computed has existed one element, call equals() to compare the new element and the element on the location
                If equals() return true, it is considered repeated element, and not add it into hash table
                If equals() return false, add it into hash table directly
               
              default hashCode() means the address of instance
              default equals() means two instances has the same address
              
  --------| TreeSet: based on red-black tree(binary tree), elements stored ordered
  	Note:
	  1. When adding elements into TreeSet, if elements has natural order, TreeSet stores elements by natural order
	  2. When adding elements into TreeSet, if element has no natural order, the class owning elements must implement 
	     Comparable, then rewrite compareTo method
	  3. When adding elements into TreeSet, if element has no natural order, the class owning elements don't implement
	     Comparable, then when creating TreeSet instance, we must pass Comparator instance
	 Comparable format:
	 class className implements Comparable {
	 @Overide
	 public int compareTo(className o) {
	 ...
	 }
	 }
	 
	 TreeSet<Person> ts = new TreeSet<Person>(new Comparator() {
	 @Override
	 public int compare(className o1, className o2) {
	 ...
	 }
	 })

Double columns:
---------| Map (key, value) pairs, key is unrepeated, value is repeated
	--------| HashMap: based on hash table
	--------| TreeMap: based on red black tree
	

************************************************
HashSet practice
***********************************************
Situation 1:
***********************************************
package cn.itcast_01;

public class Person {
	int id;
	String name;
	
	public Person(int id, String name) {
		this.id = id;
		this.name = name;
	}

	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + "]";
	}
}
package cn.itcast_01;

import java.util.HashSet;

public class HashSetTest {

	public static void main(String[] args) {
		HashSet<Person> hs = new HashSet<Person>();
		hs.add(new Person(100, "Lily"));
		hs.add(new Person(100, "Lily"));
		System.out.println(hs);
	}
}

result:
[Person [id=100, name=Lily], Person [id=100, name=Lily]]
***************************************************************
Situation 2:
***************************************************************
package cn.itcast_02;

public class Person {
	int id;
	String name;
	
	public Person(int id, String name) {
		this.id = id;
		this.name = name;
	}

	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + id;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Person other = (Person) obj;
		if (id != other.id)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}
}

package cn.itcast_02;

import java.util.HashSet;

public class HashSetTest {

	public static void main(String[] args) {
		HashSet<Person> hs = new HashSet<Person>();
		hs.add(new Person(100, "Lily"));
		hs.add(new Person(100, "Lily"));
		System.out.println(hs);
	}
}

result:
[Person [id=100, name=Lily]]
**************************************************************


****************************************************************
TreeSet practice
*****************************************************************
method 1: Comparable
*****************************************************************
package cn.itcast_03;

public class Person implements Comparable<Person> {
	int id;
	String name;
	
	public Person(int id, String name) {
		this.id = id;
		this.name = name;
	}

	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + id;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Person other = (Person) obj;
		if (id != other.id)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}

	@Override
	public int compareTo(Person p) {
		int num = this.id - p.id;
		int num2 = num == 0 ? this.name.compareTo(p.name) : num;
		return num2;
	}
}

package cn.itcast_03;

import java.util.TreeSet;

public class TreeSetTest {

	public static void main(String[] args) {
		TreeSet<Person> hs = new TreeSet<Person>();
		hs.add(new Person(100, "Lily"));
		hs.add(new Person(101, "Andy"));
		hs.add(new Person(100, "David"));
		System.out.println(hs);
	}
}

result:
[Person [id=100, name=David], Person [id=100, name=Lily], Person [id=101, name=Andy]]

**********************************************************************************
method 2: Comparator
*********************************************************************************
package cn.itcast_04;

public class Person {
	int id;
	String name;
	
	public Person(int id, String name) {
		this.id = id;
		this.name = name;
	}

	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + id;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Person other = (Person) obj;
		if (id != other.id)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}


}

package cn.itcast_04;

import java.util.Comparator;
import java.util.TreeSet;

public class TreeSetTest {

	public static void main(String[] args) {
		TreeSet<Person> hs = new TreeSet<Person>(new Comparator<Person>() {

			@Override
			public int compare(Person p1, Person p2) {
				int num = p1.id - p2.id;
				int num2 = num == 0 ? p1.name.compareTo(p2.name) : num;
				return num2;
			}});
		hs.add(new Person(100, "Lily"));
		hs.add(new Person(101, "Andy"));
		hs.add(new Person(100, "David"));

		System.out.println(hs);
	}
}

result:
[Person [id=100, name=David], Person [id=100, name=Lily], Person [id=101, name=Andy]]
********************************************************************************************

Note: for iterator, when iterator, we can't use Collection instance to modify Collection size, if we need do it, we should
use iterator to modify it.
**********************************************************************************************
package cn.itcast_05;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.Set;

public class CollectionTest {

	public static void main(String[] args) {
		// ArrayList
		ArrayList<String> strArrayList = new ArrayList<String>();
		strArrayList.add("Josh");
		strArrayList.add("Andy");
		strArrayList.add("Anele");
		
		System.out.println("ArrayList get()");
		for (int i = 0; i < strArrayList.size(); ++i) {
			System.out.println(strArrayList.get(i));
		}
		System.out.println("----------------------");
		
		System.out.println("ArrayList enhance for");
		for (String string : strArrayList) {
			System.out.println(string);
		}
		
		System.out.println("--------------------");
		
		
		// HashSet
		HashSet<String> hsHashSet = new HashSet<String>();;
		hsHashSet.add("Josh");
		hsHashSet.add("Andy");
		hsHashSet.add("Anele");
		hsHashSet.add("Anele");
		
		System.out.println("HashSet enhance for");
		for (String string : hsHashSet) {
			System.out.println(string);
		}
		System.out.println("-----------------------");
		
		System.out.println("HashSet iterator");
		Iterator<String> iter = hsHashSet.iterator();
		while (iter.hasNext()) {
			System.out.println(iter.next());
		}
		
		System.out.println("------------------");
		// HashMap		
		HashMap<String, String> hm = new HashMap<String, String>();
		hm.put("Josh", "USA");
		hm.put("Andy", "England");
		hm.put("Anele", "South Africa");
		hm.put("Andy", "Chinese");
		
		System.out.println("HashMap keySet() and get()");
		Set<String> keys = hm.keySet();
		for (String key : keys) {
			String value = hm.get(key);
			System.out.println(key+"="+value);
		}
		System.out.println("---------------------------");
		
		System.out.println("HashMap entrySet(), getKey() and getValue()");
		Set<Entry<String, String>> entrys = hm.entrySet();
		for (Entry<String, String> entry : entrys) {
			String key = entry.getKey();
			String value = entry.getValue();
			System.out.println(key+"="+value);
		}
		
		System.out.println("-----------------------");	  		
				
	}

}


result:
ArrayList get()
Josh
Andy
Anele
----------------------
ArrayList enhance for
Josh
Andy
Anele
--------------------
HashSet enhance for
Anele
Josh
Andy
-----------------------
HashSet iterator
Anele
Josh
Andy
------------------
HashMap keySet() and get()
Anele=South Africa
Josh=USA
Andy=Chinese
---------------------------
HashMap entrySet(), getKey() and getValue()
Anele=South Africa
Josh=USA
Andy=Chinese
-----------------------
genecity:
	benefits:
		A-exposure of issues during compiling instead of running period
		B-avoid some Cast type conversion
	genecity used in Collection:
		ArrayList<String> list = new ArrayList<String>(); // true
		ArrayList<Object> list = new ArrayList<String>(); // false
		ArrayList<String> list = new ArrayList<Object>(); // false
		ArrayList list = new ArrayList<String>();         // true
		ArrayList<String> list = new ArrayList();         // true
	
	Note:
		A-Genecity has no polymorphic concept, the types of two side should be the same
		B-Only specify one side type, which is ok
		C-recommend to specify the types of two sides, considering the Compatibility of old systems and new systems

	self-defined genecity: Placeholders for data types, or Variables of the data type
	
	genecity method:
		A: format
		(Modifier) <declare self-defined genecity>(return type) (method name)(List of formal parameters) {
			...
		}
		B:defined genecity's specified data type is decided when calling the method with specified data type in real parameter
		C: self-defined genecity name should be any one which obey name rules for identifiers 
		
	genecity class:
		A: format
		class className<declare self-defined genecity> {
		}
		B: when creating the instance of class, self-defined genecity will get specified data type 
		C: If we don't specify data type of class, its default data type is Object
	
	genecity interface:
		A: format
			interface interfaceName<declare self-defined genecity> {
			}
		
		B: Notice
			a: specify self-defined genecity data type when implementing its method
			b: if we don't do a step, default is Object
			c: if you want to specify self-defined genecity data type when creating one implement class instance
				implement class must add <T>
				Impl impl = new Impl<String>()
		
**************************************************************************************************
genecity method to implement method with the same data type for both return  and formal parameter
**************************************************************************************************
package cn.itcast_02;

public class GenecityTest {

	public static void main(String[] args) {
		System.out.println(print("hello"));
		System.out.println(print(123));
		System.out.println(print('a'));
	}
	
	// <T>: declare <T> as self-defined genecity
	public static<T> T print(T t) {
		return t;
	}

}

result:
hello
123
a
***********************************************************************************



***********************************************************************************
genecity class
***********************************************************************************
package cn.itcast_02;

public class MyList<T> {
	Object[] arr = new Object[10];
	int index = 0;
	
	public MyList() {}
	
	public void add(T o) {
		arr[index++] = o;
	}
}

package cn.itcast_02;

public class MyListTest {

	public static void main(String[] args) {
		MyList<Integer> intList = new MyList<Integer>();
		intList.add(100);
		intList.add(200);
		
		MyList<String> strList = new MyList<String>();
		strList.add("hello");
		strList.add("world");
		
		MyList objList = new MyList();
		objList.add("hello");
		objList.add(123);
	}
}
************************************************************************************************



*************************************************************************************************
genecity interface
*************************************************************************************************
package cn.itcast_02;

public interface Dao<T> {
	public void add(T t);
	public void remove(T t);
}


package cn.itcast_02;

public class ObjectDaoImpl implements Dao {

	@Override
	public void add(Object t) {
	}

	@Override
	public void remove(Object t) {
	}

}

package cn.itcast_02;

public class StringDaoImpl implements Dao<String> {

	@Override
	public void add(String t) {
	}

	@Override
	public void remove(String t) {
	}

}

*****************************************************************************
examples for genecity:
ArrayList
Comparator
*****************************************************************************



IO： used in transfering data between two equipments
	hard disk ---> memory
	memory ---> hard disk

IO stream:
	1-byte stream
		1.1-input stream
			-------| InputStream: all input equipments' base class, abstract class
				------| FileInputStream: read file input byte stream
				------| BufferedInputStream: buffer input byte stream,
											 the class is maintaining a 8kb byte array,
											 The class is uesed to improve the efficiency of reading file data
				
		1.2-output stream
			-------| OutputStream: all output equipments's base class, abstract class
				------| FileOutputStream: output data into file
				------| BufferedOutputStream: buffer output byte stream,
											  the class is used to improve the efficiency of writing data,
											  The class is maintaining a 8kb byte array

		The situation to use byte stream:
			After reading data, you don't need encode or decode it,
			For example, pictures

		char stream = byte stream + encode or decode

	2-char stream
		2.1 Input char stream
			----------| Reader: all input char stream's base class, abstract class
				---------| FileReader: read char data from file, input char stream
					----------| BufferedReader: buffer input char stream, 
												used to improve the efficiency of reading file char(extended function: readLine),
												maintain a char array with the length of 8192 
			
		2.2 Output char stream
			----------| Writer: all output char stream's base class, abstract class
				---------| FileWriter: output char data into file, output char stream
					----------| BufferedWriter: buffer output char stream, 
												used to improve the efficiency of writing char into file(extended function: newLine),
												maintain a char array with the length of 8192 			
		
		The situation to use char stream:
			if read and write are char data, we have to use char stream
	
	3-Conversion stream
		----------| InputStreamReader: input byte stream's conversion stream 
						
		----------| OutputStreamWriter: output byte stream's conversion stream
		
		used:
			A: convert byte stream into char stream
			B: specify encode and decode table type InputStreamReader(InputStream, String charset)
		
		FileWriter: GBK by default, we can't specify special encode and decode table, but OutputStreamWriter can
		FileReader: GBK by default, we can't specify special encode and decode table, but InputStreamReader can

********************************************************************
Coversion stream example
********************************************************************
package cn.itcast_03;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;


public class IOTest {

	public static void main(String[] args) throws IOException {
		InputStream in = System.in;
		InputStreamReader isr = new InputStreamReader(in);
		BufferedReader br = new BufferedReader(isr);
		System.out.println(br.readLine());
	}
}


result
hello world java
hello world java
*****************************************************************************
package cn.itcast_03;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;


public class IOTest {

	public static void main(String[] args) throws IOException {
		testInput();
	}
	
	static void testInput() throws IOException {
		// readLine() is commonly used
		// but only BufferedReader has readLine()
		InputStream in = System.in;
		InputStreamReader isr = new InputStreamReader(in);
		BufferedReader br = new BufferedReader(isr);
		System.out.println(br.readLine());
	}
	
	private void testOutput() throws UnknownHostException, IOException {
		// Write byte: not convenient
		// write char: convenient
		// newLine() is commonly used
		// BufferedWriter has newLine()
		Socket socket = new Socket(InetAddress.getLocalHost(), 9090);
		OutputStream os = socket.getOutputStream();
//		os.write("hello".getBytes());
		OutputStreamWriter osw = new OutputStreamWriter(os);
		BufferedWriter bw = new BufferedWriter(osw);
		bw.write("hello");
		bw.newLine();
		
	}
}

************************************************************************
one chinese word is taking up 3 bytes
****************************************************************************
package cn.itcast_03;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class FileWriterTest {

	public static void main(String[] args) throws IOException {
		writeFile();
		readFile();

	}

	private static void readFile() throws IOException {
		// method 1:
		FileReader fr = new FileReader("a.txt");
		int content = 0;
		while ((content = fr.read()) != -1) {
			System.out.print((char)content);
		}
		fr.close();
		System.out.println();
		System.out.println("-----------------");
		// method 2:
		FileInputStream fis = new FileInputStream("a.txt");
		InputStreamReader isr = new InputStreamReader(fis, "gbk");
		int content2 = 0;
		while ((content2 = isr.read()) != -1) {
			System.out.print((char)content2);
		}
		fr.close();
	}
	

	private static void writeFile() throws IOException {
		FileOutputStream fos = new FileOutputStream("a.txt");
		OutputStreamWriter osw = new OutputStreamWriter(fos, "gbk");
		osw.write("我爱你中国");
		osw.close();
	}
}

result:
�Ұ����й�
-----------------
我爱你中国
*****************************************************************************
package cn.itcast_03;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class FileWriterTest {

	public static void main(String[] args) throws IOException {
		writeFile();
		readFile();

	}

	private static void readFile() throws IOException {
		// method 1:
		FileReader fr = new FileReader("a.txt");
		int content = 0;
		while ((content = fr.read()) != -1) {
			System.out.print((char)content);
		}
		fr.close();
		System.out.println();
		System.out.println("-----------------");
		// method 2:
		FileInputStream fis = new FileInputStream("a.txt");
		InputStreamReader isr = new InputStreamReader(fis, "utf-8");
		int content2 = 0;
		while ((content2 = isr.read()) != -1) {
			System.out.print((char)content2);
		}
		fr.close();
	}
	

	private static void writeFile() throws IOException {
		FileOutputStream fos = new FileOutputStream("a.txt");
		OutputStreamWriter osw = new OutputStreamWriter(fos, "utf-8");
		osw.write("我爱你中国");
		osw.close();
	}
}

result：
我爱你中国
-----------------
我爱你中国
*****************************************************************************
Sumarize: we can specify encode or decode type by InputStreamReader and OutputStreamWriter, 
then its reader reads the same content as writer
********************************************************************************


**************************************************
Thread:
	The benefits of multithread:
		one process has many threads, each thread handles one task
	self-defined thread
		A: inherit Thread
			a: self-defined one class inheriting Thread
			b: rewrite Thread run() method, self-defined task is self-defined on run() method
			c: create Thread subclass instance, call start() method to start one thread and call run() method
		B: implement Runnable interface
			a: self-define one class implement Runnable
			b: implement run() method
			c: create Runnable implement class instance
			d: create Thread instance, pass Runnable implement class instance to Thread constructor
			e: call Thread start() method
			
	thread safe issues root cause:
		a: exist two threads or more to share the same resource
		b: operation on shared resource's must be two statements or more 
	
	thread safe issues solutions:
		a: synchonized code block
			synchonized(Lock) {
				the codes needed to be synchonized
			} 
		b: synchonized method
			Modifier synchonized (return type) (method name) (formal parameters list) {}
		
		Note:
			a: the lock used in synchonized is any lock instance;
				the lock on synchonized method is fixed
				non-static method's lock instance is this instance
				static method's lock is Class instance
			b:lock instance must be multithread shared instance, otherwise lock is invalid
			c: in synchonized clock block or synchonized method, when calling sleep(), it won't release lock instance,
			if calling wait(), it will release lock instance
		
******************************************************
package cn.itcast_05;

public class MyThread extends Thread {
//	public MyThread(String name) {
//		super(name);
//	}
	@Override
	public  void run() {
		for (int i = 0; i < 100; ++i) {
			System.out.println(Thread.currentThread().getName()+":"+i);
		}
	}
}

package cn.itcast_05;

public class MyThreadTest {

	public static void main(String[] args) {
		MyThread myThread1 = new MyThread();
		MyThread myThread2 = new MyThread();
		MyThread myThread3 = new MyThread();
		
		myThread1.setName("Lin Qingxia");
		myThread2.setName("Sun Li");
		myThread3.setName("Jiang Wenli");
		
		myThread1.start();
		myThread2.start();
		myThread3.start();
	}
}


***************************************************************************
package cn.itcast_05;

public class MyThread extends Thread {
	
	public MyThread(String name) {
		super(name);
	}
	@Override
	public  void run() {
		for (int i = 0; i < 100; ++i) {
			System.out.println(Thread.currentThread().getName()+":"+i);
		}
	}
}

package cn.itcast_05;

public class MyThreadTest {

	public static void main(String[] args) {
		MyThread myThread1 = new MyThread("Lin Qingxia");
		MyThread myThread2 = new MyThread("Sun Li");
		MyThread myThread3 = new MyThread("Jiang Wenli");
//		
//		myThread1.setName("Lin Qingxia");
//		myThread2.setName("Sun Li");
//		myThread3.setName("Jiang Wenli");
		
		myThread1.start();
		myThread2.start();
		myThread3.start();
	}
}

*****************************************************************************
package cn.itcast_05;

public class MyRunnable implements Runnable {

	@Override
	public void run() {
		for (int i = 0; i < 100; ++i) {
			System.out.println(Thread.currentThread().getName()+":"+i);
		}
	}
}

package cn.itcast_05;

public class MyRunnableTest {

	public static void main(String[] args) {
		MyRunnable myRunnable = new MyRunnable();
		Thread t1 = new Thread(myRunnable, "Lin Qingxia");
		Thread t2 = new Thread(myRunnable, "Sun Li");
		Thread t3 = new Thread(myRunnable, "Jiang Wenli");
		t1.start();
		t2.start();
		t3.start();
	}
}

*****************************************************************************
junit(unit test framework)

Current issue:
	a: all methods should be called in main()
	b: Results should be checked manually
	
https://junit.org/junit5/docs/current/api/
https://junit.org/junit5/docs/current/user-guide/index.pdf
https://github.com/junit-team/junit5/

A: download junit-*.*.jar on the internet
B: create Folder lib in the current project
C: right click on the jar->Build Path->Add Build Path->
   Then Referenced Libraries generated automatically

Notice:
	A: If we test one method by junit, green junit bar shows test case passes
	B: If we test one method by junit, red junit bar shows test case fails
	C: If you click on method name, class name, package name, project name, then run JUnit Test, it will run
	   all classes's test method, class, package, project and project all test method
	D: @Test method should not be static and shouldn't has formal parameter lists
	

junit using rules:
	A: If one class need be tested, the class is related to one test class
		test case name: (class name tested) +Test.
	B: one tested method is related to one test method
		test method name: test+(tested method name)
**********************************************************************************************
package cn.itcast_06;

import java.util.Arrays;

import org.junit.Test;

public class SortTest {
	@Test
	public void sort() {
		int[] arr = {10, 2, 20, 3, 5};
		
		for (int i = 0; i < arr.length - 1; ++i) {
			for (int j = i + 1; j < arr.length; ++j) {
				if (arr[i] > arr[j]) {
					int temp = arr[i];
					arr[i] = arr[j];
					arr[j] = temp;
				}
			}
		}
		System.out.println(Arrays.toString(arr));
	}
}

result:
[2, 3, 5, 10, 20]
**************************************************************************************************
1-Whatever method you want to test, you can choose the method name then click on Run as->JUnit Test,
only the chosen method is tested
2-If you want to test whole class, you can choose the test class name 
3-If you want to test whole package, you should choose the tested package
4-If you want to test whole project, you should choose the tested project
**************************************************************************************************
package cn.itcast_06;

import java.util.Arrays;

import org.junit.Test;

public class SortTest {
	@Test
	public void sort() {
		int[] arr = {10, 2, 20, 3, 5};
		
		for (int i = 0; i < arr.length - 1; ++i) {
			for (int j = i + 1; j < arr.length; ++j) {
				if (arr[i] > arr[j]) {
					int temp = arr[i];
					arr[i] = arr[j];
					arr[j] = temp;
				}
			}
		}
		System.out.println(Arrays.toString(arr));
	}
	
	@Test
	public void getMax() {
		int a = 10;
		int b = 20;
		int max =  (a > b) ? a : b;
		System.out.println("max value is "+max);
	}
}

result:
max value is 20 for getMax
[2, 3, 5, 10, 20] for sort
************************************************************************

However, we should divide product code and test code into two different files

************************************************************************
package cn.itcast_07;

public class Tool {
	public int getMax(int a, int b) {
		return a > b ? a : b;
	}

	public int getMin(int a, int b) {
		return a < b ? a : b;
	}
}

package cn.itcast_07;

import org.junit.Test;

public class ToolTest {
	@Test
	public void testGetMax() {
		int a = 3;
		int b = 5;
		int max = new Tool().getMax(a, b);
		System.out.println("max value:"+max);
	}
	
	@Test
	public void testGetMin() {
		int a = 3;
		int b = 5;
		int min = new Tool().getMin(a, b);
		System.out.println("min value:"+min);
	}
}

result:
max value:5
min value:3
***************************************************************************
Assert.assertSame
Assert.assertNotSame
Assert.assertEquals
Assert.assertNull
Assert.assertNotNull
Assert.assertTrue
Assert.assertFalse
******************************************************************************
package cn.itcast_06;

public class Tool {
	public int getMax(int a, int b) {
		return a > b ? a : b;
	}
	
	public int getMin(int a, int b) {
		return a < b ? a : b;
	}

}

package cn.itcast_06;

import org.junit.jupiter.api.Test;

import junit.framework.Assert;


public class ToolTest {
	@Test
	public void testGetMax() {
		int a = 3;
		int b = 5;
		int actual = new Tool().getMax(a, b);
		Assert.assertSame(5, actual);// ==: address
		Assert.assertNotSame("abc", new String("abc"));
//		Assert.assertSame(new String("abc"), "abc"); // ==, red
		Assert.assertEquals(new String("abc"), "abc"); // String equals, green
	}
	
	@Test
	public void testGetMin() {
		int a = 3;
		int b = 5;
		int actual = new Tool().getMin(a, b);
		int expected = 3;
		Assert.assertSame(expected, actual);
		
		Assert.assertNull(null);
		Assert.assertNotNull("abc");
		
		Assert.assertFalse( 5 == 6);
		Assert.assertTrue(2 == 2);
	}
}
**********************************************************************
@Before: before each tested method, many times
@After: after each tested method, many times
@BeforeClass: before all tested methods, once
@AfterClass: after all tested methods, once
***********************************************************************
package cn.itcast_07;

import java.io.FileInputStream;
import java.io.IOException;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class ReadFile {
	@Before
	public void prepareEnvironment() {
		System.out.println("Environment is ready...");
	}
	
	@Test
	public void FileRead() throws IOException {
		FileInputStream fis = new FileInputStream("a.txt");
		int content = 0;
		while ((content = fis.read()) != -1) {
			System.out.println((char)content);
		}
		fis.close();
	}
	
	@Test
	public void sort() {
		System.out.println("Sort");
	}
	
	@After
	public void clearEnvironment() {
		System.out.println("Environment is clear...");
	}

}


result:
Environment is ready...
a
b
c
Environment is clear...
Environment is ready...
Sort
Environment is clear...

******************************************
package cn.itcast_07;

import java.io.FileInputStream;
import java.io.IOException;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

public class ReadFile {
	@BeforeClass
	public static void prepareEnvironment() {
		System.out.println("Environment is ready...");
	}
	
	@Test
	public void FileRead() throws IOException {
		FileInputStream fis = new FileInputStream("a.txt");
		int content = 0;
		while ((content = fis.read()) != -1) {
			System.out.println((char)content);
		}
		fis.close();
	}
	
	@Test
	public void sort() {
		System.out.println("Sort");
	}
	
	@AfterClass
	public static void clearEnvironment() {
		System.out.println("Environment is clear...");
	}

}

Environment is ready...
a
b
c
Sort
Environment is clear...
****************************************************
Introspector: 内省--一种变态的反射
内省主要解决的问题是：把对象的属性值封装到对象中
**************************************************************8

package cn.itcast_08;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import org.junit.Test;


public class IntrospectorTest {
	@Test
	// get all get method name
	public void getAllProperties() throws IntrospectionException {
		BeanInfo info = Introspector.getBeanInfo(Person.class);
		PropertyDescriptor[] descriptors = info.getPropertyDescriptors();
		for (PropertyDescriptor descriptor : descriptors) {
			System.out.println(descriptor.getReadMethod());
		}
		
		
	}
	

	@Test
	// for class with many data members, it is not suitable
	public void testProperty() throws IntrospectionException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		Person person = new Person();
		PropertyDescriptor descriptorId = new PropertyDescriptor("id", Person.class);
		Method setId = descriptorId.getWriteMethod();
		setId.invoke(person, 100);
		Method getId = descriptorId.getReadMethod();
		System.out.println(getId.invoke(person, null));
		
		PropertyDescriptor descriptorName = new PropertyDescriptor("name", Person.class);
		Method setName = descriptorName.getWriteMethod();
		setName.invoke(person, "Andy");
		Method getName = descriptorName.getReadMethod();
		System.out.println(getName.invoke(person, null));
	}
}

result：
100
Andy
public final native java.lang.Class java.lang.Object.getClass()
public int cn.itcast_08.Person.getId()
public java.lang.String cn.itcast_08.Person.getName()
***************************************************************************

Apache BeanUtils
*************************************************
Download BeanUtils on the internet
copy it to lib folder
Add build path
**********************************************************
BeanUtils: 把对象的属性值封装到对象中，
但是更简单

内省的前提：
	类必须定义了setXxx和getXxx方法才可以
****************************************************
JUnit can be added by eclipse own software
Click on the project name
	Build Path
		Add Libraries
			JUnit
				Choose JUnit library version
					Finish

*****************************************************************************				
BeanUtils: 一种变态的反射
目的是： 将对象的属性值封装到对象中
API
http://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.3/apidocs/index.html

Issue: java.lang.NoClassDefFoundError: org/apache/commons/logging/LogFactory
solution: need add library commons.logging.jar


BeanUtils steps:
	import package: commons-logging.jar, commons-beanutils-1.8.0.jar

Benefits:
	A-BeanUtils设置属性值时，如果属性值是基本数据类型时，BeanUtils会帮我们自动转换数据类型
	B-BeanUtils设置属性值时，底层也是依据get或者set来获取或者设置属性值的
	C-BeanUtils设置属性值，如果设置的属性是其他引用类型时，需要注册一个类型转换器（ConvertUtils.register）
	
Issue: Converter.convert method has no right type and value formal parameter
soulution: Click on "ConvertUtils"->
			click on "Attach Source"->
				choose BeanUtils source code jar package

******************************************************************************
convert: 
	type: 目前遇到的数据类型
	value：目前参数的值
******************************************************************************
BeanUtils.setProperty
BeanUtils.getProperty
public static String getProperty(Object bean,
                                 String name)
                          throws IllegalAccessException,
                                 InvocationTargetException,
                                 NoSuchMethodException
public static void setProperty(Object bean,
                               String name,
                               Object value)
                        throws IllegalAccessException,
                               InvocationTargetException
******************************************************************************
CovertUtil
Converter
******************************************************************************
public static void register(Converter converter,
                            Class<?> clazz)

org.apache.commons.beanutils
	Interface Converter
public <T> T convert(Class<T> type, Object value);
******************************************************************************
							
package cn.itcast_08;

public class Person {
	int id;
	String name;
	
	public Person(int id, String name) {
		this.id = id;
		this.name = name;
	}

	public Person() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		
		return "number:"+this.id+", name:"+this.name;
	}
}

package cn.itcast_08;

import org.apache.commons.beanutils.BeanUtils;

public class PersonTest {
	public static void main(String[] args) throws Exception {
		Person person = new Person();
		BeanUtils.setProperty(person, "id", "100");
		System.out.println(BeanUtils.getProperty(person, "id"));
		BeanUtils.setProperty(person, "name", "Andy");
		System.out.println(BeanUtils.getProperty(person, "name"));
		System.out.println(person);
	}
}

result:
100
Andy
number:100, name:Andy
********************************************************************************
package cn.itcast_08;

import java.util.Date;

public class Employee {
	private int id;
	private String name;
	private double salary;
	private Date birthday;
	public Employee() {
		super();
		
	}
	public Employee(int id, String name, double salary, Date birthday) {
		super();
		this.id = id;
		this.name = name;
		this.salary = salary;
		this.birthday = birthday;
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public double getSalary() {
		return salary;
	}
	public void setSalary(double salary) {
		this.salary = salary;
	}
	public Date getBirthday() {
		return birthday;
	}
	public void setBirthday(Date birthday) {
		this.birthday = birthday;
	}
	
	@Override
	public String toString() {
		
		return "id:"+this.id+
				", name:"+this.name+
				", salary:"+this.salary+
				",birthday:"+this.birthday;
	}
	

}

package cn.itcast_08;

import java.text.SimpleDateFormat;
import java.util.Date;

import org.apache.commons.beanutils.BeanUtils;
import org.apache.commons.beanutils.ConvertUtils;
import org.apache.commons.beanutils.Converter;

public class EmployeeTest {

	public static void main(String[] args) throws Exception {
		ConvertUtils.register(new Converter() {
			
			@Override
			public Object convert(Class type, Object value) {
				Date date = null;
				try {
					SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
					date = sdf.parse((String)value);
				} catch(Exception e) {
					e.printStackTrace();
				}
				return date;
			}
		}, Date.class);
		Employee employee = new Employee();
		BeanUtils.setProperty(employee, "id", "100");
		BeanUtils.setProperty(employee, "name", "Andy");
		BeanUtils.setProperty(employee, "salary", "50000");
		BeanUtils.setProperty(employee, "birthday", "1960-09-01");
		System.out.println(employee);

	}
}

result:
id:100, name:Andy, salary:50000.0,birthday:Thu Sep 01 00:00:00 CST 1960
**************************************************************************************
以后的数据库的用户名和密码一般都会保存到properties（配置文件）
**************************************************************************************
package cn.itcast_09;

public class Demo1 {
	static String name = "Andy";
	static String password = "123456";
	public static void main(String[] args) {
		System.out.println("username="+name+", password="+password);
	}

}

***************************************************************************************
javac -d . Demo1.java // it will generate all dirs and class file, then remove java file
java cn.itcast_09.Demo1 // result: username=Andy, password=123456
***************************************************************************************
If we want to change username and password, we need do the above opetions again
******************************************************************************************
db.properties
username=root
password=12345678
*******************************************************************************************
package cn.itcast_11;

import java.io.FileReader;
import java.io.IOException;
import java.util.Properties;

public class DBUtil {
	static Properties properties;
	
	static {
		properties = new Properties();
		try {
			properties.load(new FileReader("db.properties"));
		} catch (IOException e) {
			
			e.printStackTrace();
		}
		
	}
	
	public static void main(String[] args) {
		System.out.println("username:"+properties.getProperty("username")
		+", password:"+properties.getProperty("password"));
	}
}

cpoy db.properties and DBUtil.java to C:\\demo2
cd C:\\demo2
javac -d . DBUtil.java
java cn.itcast_11.DBUtil
result:
username:root, password:12345678

Then remove DBUtil.java
modify db.properties(password=7890)
java cn.itcast_11.DBUtil
result:
username:root, password:7890
**********************************************************************************
如果经常发生变化的数据我们可以定义在配置文件上，比如说，数据库的用户名和密码
配置文件的路径如何写呢？
	绝对路径： 包含盘符的完整路径，不能做到在所有操作系统上通用（某些系统没有盘符）
	相对路径： 相对于当前程序的所在的路径。程序当前的路径，就是执行java命令时控制台所在的路径。当切换控制台路径时，不安全
	类文件路径： 类文件路径就是使用了classpath的路径找对应的源文件
		如果需要使用类文件路径，首先要获取到一个Class对象
			（Class getResourceAsStream该方法里面使用的路径就是类文件路径）
		如何没有set classpath, 使用当前控制台的路径
*********************************************************************************
package cn.itcast_11;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

public class DBUtil {
	static Properties properties;
	
	static {
		properties = new Properties();
		try {
			Class clazz = DBUtil.class;
			InputStream is = clazz.getResourceAsStream("/db.properties");// "/"  代表了classpath的路径
			properties.load(is);
			//			properties.load(new FileReader("db.properties"));
		} catch (IOException e) {
			
			e.printStackTrace();
		}
		
	}
	
	public static void main(String[] args) {
//		System.out.println("Current path:"+new File(".").getAbsolutePath());
		System.out.println("username:"+properties.getProperty("username")
		+", password:"+properties.getProperty("password"));
	}
}

cd C:\\demo2(db.properties)
javac -d . DBUtil.java
set classpath=“C:\\demo2”
cd C:\\demo1(no db.properties)
java cn.itcast_11.DBUtil
******************************************************************************************
	
