Single column:
Collection: Single column collection root interface
----| List: ordered, repeated
  --------| ArrayList: based on Object instance array, find fast(memory address is continuous), add and delete slow(copy all)
  --------| Vector: based on Object instance array, but thread-safe
  --------| LinkedList: based on linked list, find slow, add and delete fast
----| Set: unordered, unrepeated
  --------| HashSet: based on hash table, store and get fast
              hashCode() and equals()
              When adding elements into HashSet, call hashCode() at first to get the hash code value,
              then compute the location of elements according to hash code value;
              If the location computed has not existed any elements, add it into hash table directly
              If the location computed has existed one element, call equals() to compare the new element and the element on the location
                If equals() return true, it is considered repeated element, and not add it into hash table
                If equals() return false, add it into hash table directly
               
              default hashCode() means the address of instance
              default equals() means two instances has the same address
              
  --------| TreeSet: based on red-black tree(binary tree), elements stored ordered
  	Note:
	  1. When adding elements into TreeSet, if elements has natural order, TreeSet stores elements by natural order
	  2. When adding elements into TreeSet, if element has no natural order, the class owning elements must implement 
	     Comparable, then rewrite compareTo method
	  3. When adding elements into TreeSet, if element has no natural order, the class owning elements don't implement
	     Comparable, then when creating TreeSet instance, we must pass Comparator instance
	 Comparable format:
	 class className implements Comparable {
	 @Overide
	 public int compareTo(className o) {
	 ...
	 }
	 }
	 
	 TreeSet<Person> ts = new TreeSet<Person>(new Comparator() {
	 @Override
	 public int compare(className o1, className o2) {
	 ...
	 }
	 })

Double column:

************************************************
HashSet practice
***********************************************
Situation 1:
***********************************************
package cn.itcast_01;

public class Person {
	int id;
	String name;
	
	public Person(int id, String name) {
		this.id = id;
		this.name = name;
	}

	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + "]";
	}
}
package cn.itcast_01;

import java.util.HashSet;

public class HashSetTest {

	public static void main(String[] args) {
		HashSet<Person> hs = new HashSet<Person>();
		hs.add(new Person(100, "Lily"));
		hs.add(new Person(100, "Lily"));
		System.out.println(hs);
	}
}

result:
[Person [id=100, name=Lily], Person [id=100, name=Lily]]
***************************************************************
Situation 2:
***************************************************************
package cn.itcast_02;

public class Person {
	int id;
	String name;
	
	public Person(int id, String name) {
		this.id = id;
		this.name = name;
	}

	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + id;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Person other = (Person) obj;
		if (id != other.id)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}
}

package cn.itcast_02;

import java.util.HashSet;

public class HashSetTest {

	public static void main(String[] args) {
		HashSet<Person> hs = new HashSet<Person>();
		hs.add(new Person(100, "Lily"));
		hs.add(new Person(100, "Lily"));
		System.out.println(hs);
	}
}

result:
[Person [id=100, name=Lily]]
**************************************************************


****************************************************************
TreeSet practice
*****************************************************************
method 1: Comparable
*****************************************************************
package cn.itcast_03;

public class Person implements Comparable<Person> {
	int id;
	String name;
	
	public Person(int id, String name) {
		this.id = id;
		this.name = name;
	}

	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + id;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Person other = (Person) obj;
		if (id != other.id)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}

	@Override
	public int compareTo(Person p) {
		int num = this.id - p.id;
		int num2 = num == 0 ? this.name.compareTo(p.name) : num;
		return num2;
	}
}

package cn.itcast_03;

import java.util.TreeSet;

public class TreeSetTest {

	public static void main(String[] args) {
		TreeSet<Person> hs = new TreeSet<Person>();
		hs.add(new Person(100, "Lily"));
		hs.add(new Person(101, "Andy"));
		hs.add(new Person(100, "David"));
		System.out.println(hs);
	}
}

result:
[Person [id=100, name=David], Person [id=100, name=Lily], Person [id=101, name=Andy]]

**********************************************************************************
method 2: Comparator
*********************************************************************************
package cn.itcast_04;

public class Person {
	int id;
	String name;
	
	public Person(int id, String name) {
		this.id = id;
		this.name = name;
	}

	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + id;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Person other = (Person) obj;
		if (id != other.id)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}


}

package cn.itcast_04;

import java.util.Comparator;
import java.util.TreeSet;

public class TreeSetTest {

	public static void main(String[] args) {
		TreeSet<Person> hs = new TreeSet<Person>(new Comparator<Person>() {

			@Override
			public int compare(Person p1, Person p2) {
				int num = p1.id - p2.id;
				int num2 = num == 0 ? p1.name.compareTo(p2.name) : num;
				return num2;
			}});
		hs.add(new Person(100, "Lily"));
		hs.add(new Person(101, "Andy"));
		hs.add(new Person(100, "David"));

		System.out.println(hs);
	}
}

result:
[Person [id=100, name=David], Person [id=100, name=Lily], Person [id=101, name=Andy]]
********************************************************************************************
