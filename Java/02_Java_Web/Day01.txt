Single column:
Collection: Single column collection root interface
----| List: ordered, repeated
  --------| ArrayList: based on Object instance array, find fast(memory address is continuous), add and delete slow(copy all)
  --------| Vector: based on Object instance array, but thread-safe
  --------| LinkedList: based on linked list, find slow, add and delete fast
----| Set: unordered, unrepeated
  --------| HashSet: based on hash table, store and get fast
              hashCode() and equals()
              When adding elements into HashSet, call hashCode() at first to get the hash code value,
              then compute the location of elements according to hash code value;
              If the location computed has not existed any elements, add it into hash table directly
              If the location computed has existed one element, call equals() to compare the new element and the element on the location
                If equals() return true, it is considered repeated element, and not add it into hash table
                If equals() return false, add it into hash table directly
               
              default hashCode() means the address of instance
              default equals() means two instances has the same address
              
  --------| TreeSet: based on red-black tree(binary tree), elements stored ordered
  	Note:
	  1. When adding elements into TreeSet, if elements has natural order, TreeSet stores elements by natural order
	  2. When adding elements into TreeSet, if element has no natural order, the class owning elements must implement 
	     Comparable, then rewrite compareTo method
	  3. When adding elements into TreeSet, if element has no natural order, the class owning elements don't implement
	     Comparable, then when creating TreeSet instance, we must pass Comparator instance
	 Comparable format:
	 class className implements Comparable {
	 @Overide
	 public int compareTo(className o) {
	 ...
	 }
	 }
	 
	 TreeSet<Person> ts = new TreeSet<Person>(new Comparator() {
	 @Override
	 public int compare(className o1, className o2) {
	 ...
	 }
	 })

Double columns:
---------| Map (key, value) pairs, key is unrepeated, value is repeated
	--------| HashMap: based on hash table
	--------| TreeMap: based on red black tree
	

************************************************
HashSet practice
***********************************************
Situation 1:
***********************************************
package cn.itcast_01;

public class Person {
	int id;
	String name;
	
	public Person(int id, String name) {
		this.id = id;
		this.name = name;
	}

	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + "]";
	}
}
package cn.itcast_01;

import java.util.HashSet;

public class HashSetTest {

	public static void main(String[] args) {
		HashSet<Person> hs = new HashSet<Person>();
		hs.add(new Person(100, "Lily"));
		hs.add(new Person(100, "Lily"));
		System.out.println(hs);
	}
}

result:
[Person [id=100, name=Lily], Person [id=100, name=Lily]]
***************************************************************
Situation 2:
***************************************************************
package cn.itcast_02;

public class Person {
	int id;
	String name;
	
	public Person(int id, String name) {
		this.id = id;
		this.name = name;
	}

	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + id;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Person other = (Person) obj;
		if (id != other.id)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}
}

package cn.itcast_02;

import java.util.HashSet;

public class HashSetTest {

	public static void main(String[] args) {
		HashSet<Person> hs = new HashSet<Person>();
		hs.add(new Person(100, "Lily"));
		hs.add(new Person(100, "Lily"));
		System.out.println(hs);
	}
}

result:
[Person [id=100, name=Lily]]
**************************************************************


****************************************************************
TreeSet practice
*****************************************************************
method 1: Comparable
*****************************************************************
package cn.itcast_03;

public class Person implements Comparable<Person> {
	int id;
	String name;
	
	public Person(int id, String name) {
		this.id = id;
		this.name = name;
	}

	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + id;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Person other = (Person) obj;
		if (id != other.id)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}

	@Override
	public int compareTo(Person p) {
		int num = this.id - p.id;
		int num2 = num == 0 ? this.name.compareTo(p.name) : num;
		return num2;
	}
}

package cn.itcast_03;

import java.util.TreeSet;

public class TreeSetTest {

	public static void main(String[] args) {
		TreeSet<Person> hs = new TreeSet<Person>();
		hs.add(new Person(100, "Lily"));
		hs.add(new Person(101, "Andy"));
		hs.add(new Person(100, "David"));
		System.out.println(hs);
	}
}

result:
[Person [id=100, name=David], Person [id=100, name=Lily], Person [id=101, name=Andy]]

**********************************************************************************
method 2: Comparator
*********************************************************************************
package cn.itcast_04;

public class Person {
	int id;
	String name;
	
	public Person(int id, String name) {
		this.id = id;
		this.name = name;
	}

	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + id;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Person other = (Person) obj;
		if (id != other.id)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}


}

package cn.itcast_04;

import java.util.Comparator;
import java.util.TreeSet;

public class TreeSetTest {

	public static void main(String[] args) {
		TreeSet<Person> hs = new TreeSet<Person>(new Comparator<Person>() {

			@Override
			public int compare(Person p1, Person p2) {
				int num = p1.id - p2.id;
				int num2 = num == 0 ? p1.name.compareTo(p2.name) : num;
				return num2;
			}});
		hs.add(new Person(100, "Lily"));
		hs.add(new Person(101, "Andy"));
		hs.add(new Person(100, "David"));

		System.out.println(hs);
	}
}

result:
[Person [id=100, name=David], Person [id=100, name=Lily], Person [id=101, name=Andy]]
********************************************************************************************

Note: for iterator, when iterator, we can't use Collection instance to modify Collection size, if we need do it, we should
use iterator to modify it.
**********************************************************************************************
package cn.itcast_05;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.Set;

public class CollectionTest {

	public static void main(String[] args) {
		// ArrayList
		ArrayList<String> strArrayList = new ArrayList<String>();
		strArrayList.add("Josh");
		strArrayList.add("Andy");
		strArrayList.add("Anele");
		
		System.out.println("ArrayList get()");
		for (int i = 0; i < strArrayList.size(); ++i) {
			System.out.println(strArrayList.get(i));
		}
		System.out.println("----------------------");
		
		System.out.println("ArrayList enhance for");
		for (String string : strArrayList) {
			System.out.println(string);
		}
		
		System.out.println("--------------------");
		
		
		// HashSet
		HashSet<String> hsHashSet = new HashSet<String>();;
		hsHashSet.add("Josh");
		hsHashSet.add("Andy");
		hsHashSet.add("Anele");
		hsHashSet.add("Anele");
		
		System.out.println("HashSet enhance for");
		for (String string : hsHashSet) {
			System.out.println(string);
		}
		System.out.println("-----------------------");
		
		System.out.println("HashSet iterator");
		Iterator<String> iter = hsHashSet.iterator();
		while (iter.hasNext()) {
			System.out.println(iter.next());
		}
		
		System.out.println("------------------");
		// HashMap		
		HashMap<String, String> hm = new HashMap<String, String>();
		hm.put("Josh", "USA");
		hm.put("Andy", "England");
		hm.put("Anele", "South Africa");
		hm.put("Andy", "Chinese");
		
		System.out.println("HashMap keySet() and get()");
		Set<String> keys = hm.keySet();
		for (String key : keys) {
			String value = hm.get(key);
			System.out.println(key+"="+value);
		}
		System.out.println("---------------------------");
		
		System.out.println("HashMap entrySet(), getKey() and getValue()");
		Set<Entry<String, String>> entrys = hm.entrySet();
		for (Entry<String, String> entry : entrys) {
			String key = entry.getKey();
			String value = entry.getValue();
			System.out.println(key+"="+value);
		}
		
		System.out.println("-----------------------");	  		
				
	}

}


result:
ArrayList get()
Josh
Andy
Anele
----------------------
ArrayList enhance for
Josh
Andy
Anele
--------------------
HashSet enhance for
Anele
Josh
Andy
-----------------------
HashSet iterator
Anele
Josh
Andy
------------------
HashMap keySet() and get()
Anele=South Africa
Josh=USA
Andy=Chinese
---------------------------
HashMap entrySet(), getKey() and getValue()
Anele=South Africa
Josh=USA
Andy=Chinese
-----------------------
genecity:
	benefits:
		A-exposure of issues during compiling instead of running period
		B-avoid some Cast type conversion
	genecity used in Collection:
		ArrayList<String> list = new ArrayList<String>(); // true
		ArrayList<Object> list = new ArrayList<String>(); // false
		ArrayList<String> list = new ArrayList<Object>(); // false
		ArrayList list = new ArrayList<String>();         // true
		ArrayList<String> list = new ArrayList();         // true
	
	Note:
		A-Genecity has no polymorphic concept, the types of two side should be the same
		B-Only specify one side type, which is ok
		C-recommend to specify the types of two sides, considering the Compatibility of old systems and new systems

	self-defined genecity: Placeholders for data types, or Variables of the data type
	
	genecity method:
		A: format
		(Modifier) <declare self-defined genecity>(return type) (method name)(List of formal parameters) {
			...
		}
		B:defined genecity's specified data type is decided when calling the method with specified data type in real parameter
		C: self-defined genecity name should be any one which obey name rules for identifiers 
		
	genecity class:
		A: format
		class className<declare self-defined genecity> {
		}
		B: when creating the instance of class, self-defined genecity will get specified data type 
		C: If we don't specify data type of class, its default data type is Object
	
	genecity interface:
		A: format
			interface interfaceName<declare self-defined genecity> {
			}
		
		B: Notice
			a: specify self-defined genecity data type when implementing its method
			b: if we don't do a step, default is Object
			c: if you want to specify self-defined genecity data type when creating one implement class instance
				implement class must add <T>
				Impl impl = new Impl<String>()
		
**************************************************************************************************
genecity method to implement method with the same data type for both return  and formal parameter
**************************************************************************************************
package cn.itcast_02;

public class GenecityTest {

	public static void main(String[] args) {
		System.out.println(print("hello"));
		System.out.println(print(123));
		System.out.println(print('a'));
	}
	
	// <T>: declare <T> as self-defined genecity
	public static<T> T print(T t) {
		return t;
	}

}

result:
hello
123
a
***********************************************************************************



***********************************************************************************
genecity class
***********************************************************************************
package cn.itcast_02;

public class MyList<T> {
	Object[] arr = new Object[10];
	int index = 0;
	
	public MyList() {}
	
	public void add(T o) {
		arr[index++] = o;
	}
}

package cn.itcast_02;

public class MyListTest {

	public static void main(String[] args) {
		MyList<Integer> intList = new MyList<Integer>();
		intList.add(100);
		intList.add(200);
		
		MyList<String> strList = new MyList<String>();
		strList.add("hello");
		strList.add("world");
		
		MyList objList = new MyList();
		objList.add("hello");
		objList.add(123);
	}
}
************************************************************************************************



*************************************************************************************************
genecity interface
*************************************************************************************************
package cn.itcast_02;

public interface Dao<T> {
	public void add(T t);
	public void remove(T t);
}


package cn.itcast_02;

public class ObjectDaoImpl implements Dao {

	@Override
	public void add(Object t) {
	}

	@Override
	public void remove(Object t) {
	}

}

package cn.itcast_02;

public class StringDaoImpl implements Dao<String> {

	@Override
	public void add(String t) {
	}

	@Override
	public void remove(String t) {
	}

}

*****************************************************************************
examples for genecity:
ArrayList
Comparator
*****************************************************************************



IO： used in transfering data between two equipments
	hard disk ---> memory
	memory ---> hard disk

IO stream:
	1-byte stream
		1.1-input stream
			-------| InputStream: all input equipments' base class, abstract class
				------| FileInputStream: read file input byte stream
				------| BufferedInputStream: buffer input byte stream,
											 the class is maintaining a 8kb byte array,
											 The class is uesed to improve the efficiency of reading file data
				
		1.2-output stream
			-------| OutputStream: all output equipments's base class, abstract class
				------| FileOutputStream: output data into file
				------| BufferedOutputStream: buffer output byte stream,
											  the class is used to improve the efficiency of writing data,
											  The class is maintaining a 8kb byte array

		The situation to use byte stream:
			After reading data, you don't need encode or decode it,
			For example, pictures

		char stream = byte stream + encode or decode

	2-char stream
		2.1 Input char stream
			----------| Reader: all input char stream's base class, abstract class
				---------| FileReader: read char data from file, input char stream
					----------| BufferedReader: buffer input char stream, 
												used to improve the efficiency of reading file char(extended function: readLine),
												maintain a char array with the length of 8192 
			
		2.2 Output char stream
			----------| Writer: all output char stream's base class, abstract class
				---------| FileWriter: output char data into file, output char stream
					----------| BufferedWriter: buffer output char stream, 
												used to improve the efficiency of writing char into file(extended function: newLine),
												maintain a char array with the length of 8192 			
		
		The situation to use char stream:
			if read and write are char data, we have to use char stream
	
	3-Conversion stream
		----------| InputStreamReader: input byte stream's conversion stream 
						
		----------| OutputStreamWriter: output byte stream's conversion stream
		
		used:
			A: convert byte stream into char stream
			B: specify encode and decode table type InputStreamReader(InputStream, String charset)
		
		FileWriter: GBK by default, we can't specify special encode and decode table, but OutputStreamWriter can
		FileReader: GBK by default, we can't specify special encode and decode table, but InputStreamReader can

********************************************************************
Coversion stream example
********************************************************************
package cn.itcast_03;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;


public class IOTest {

	public static void main(String[] args) throws IOException {
		InputStream in = System.in;
		InputStreamReader isr = new InputStreamReader(in);
		BufferedReader br = new BufferedReader(isr);
		System.out.println(br.readLine());
	}
}


result
hello world java
hello world java
*****************************************************************************
package cn.itcast_03;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;


public class IOTest {

	public static void main(String[] args) throws IOException {
		testInput();
	}
	
	static void testInput() throws IOException {
		// readLine() is commonly used
		// but only BufferedReader has readLine()
		InputStream in = System.in;
		InputStreamReader isr = new InputStreamReader(in);
		BufferedReader br = new BufferedReader(isr);
		System.out.println(br.readLine());
	}
	
	private void testOutput() throws UnknownHostException, IOException {
		// Write byte: not convenient
		// write char: convenient
		// newLine() is commonly used
		// BufferedWriter has newLine()
		Socket socket = new Socket(InetAddress.getLocalHost(), 9090);
		OutputStream os = socket.getOutputStream();
//		os.write("hello".getBytes());
		OutputStreamWriter osw = new OutputStreamWriter(os);
		BufferedWriter bw = new BufferedWriter(osw);
		bw.write("hello");
		bw.newLine();
		
	}
}

************************************************************************
one chinese word is taking up 3 bytes
****************************************************************************
package cn.itcast_03;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class FileWriterTest {

	public static void main(String[] args) throws IOException {
		writeFile();
		readFile();

	}

	private static void readFile() throws IOException {
		// method 1:
		FileReader fr = new FileReader("a.txt");
		int content = 0;
		while ((content = fr.read()) != -1) {
			System.out.print((char)content);
		}
		fr.close();
		System.out.println();
		System.out.println("-----------------");
		// method 2:
		FileInputStream fis = new FileInputStream("a.txt");
		InputStreamReader isr = new InputStreamReader(fis, "gbk");
		int content2 = 0;
		while ((content2 = isr.read()) != -1) {
			System.out.print((char)content2);
		}
		fr.close();
	}
	

	private static void writeFile() throws IOException {
		FileOutputStream fos = new FileOutputStream("a.txt");
		OutputStreamWriter osw = new OutputStreamWriter(fos, "gbk");
		osw.write("我爱你中国");
		osw.close();
	}
}

result:
�Ұ����й�
-----------------
我爱你中国
*****************************************************************************
package cn.itcast_03;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class FileWriterTest {

	public static void main(String[] args) throws IOException {
		writeFile();
		readFile();

	}

	private static void readFile() throws IOException {
		// method 1:
		FileReader fr = new FileReader("a.txt");
		int content = 0;
		while ((content = fr.read()) != -1) {
			System.out.print((char)content);
		}
		fr.close();
		System.out.println();
		System.out.println("-----------------");
		// method 2:
		FileInputStream fis = new FileInputStream("a.txt");
		InputStreamReader isr = new InputStreamReader(fis, "utf-8");
		int content2 = 0;
		while ((content2 = isr.read()) != -1) {
			System.out.print((char)content2);
		}
		fr.close();
	}
	

	private static void writeFile() throws IOException {
		FileOutputStream fos = new FileOutputStream("a.txt");
		OutputStreamWriter osw = new OutputStreamWriter(fos, "utf-8");
		osw.write("我爱你中国");
		osw.close();
	}
}

result：
我爱你中国
-----------------
我爱你中国
*****************************************************************************
Sumarize: we can specify encode or decode type by InputStreamReader and OutputStreamWriter, 
then its reader reads the same content as writer
********************************************************************************


**************************************************
Thread:
	The benefits of multithread:
		one process has many threads, each thread handles one task
	self-defined thread
		A: inherit Thread
			a: self-defined one class inheriting Thread
			b: rewrite Thread run() method, self-defined task is self-defined on run() method
			c: create Thread subclass instance, call start() method to start one thread and call run() method
		B: implement Runnable interface
			a: self-define one class implement Runnable
			b: implement run() method
			c: create Runnable implement class instance
			d: create Thread instance, pass Runnable implement class instance to Thread constructor
			e: call Thread start() method
			
	thread safe issues root cause:
		a: exist two threads or more to share the same resource
		b: operation on shared resource's must be two statements or more 
	
	thread safe issues solutions:
		a: synchonized code block
			synchonized(Lock) {
				the codes needed to be synchonized
			} 
		b: synchonized method
			Modifier synchonized (return type) (method name) (formal parameters list) {}
		
		Note:
			a: the lock used in synchonized is any lock instance;
				the lock on synchonized method is fixed
				non-static method's lock instance is this instance
				static method's lock is Class instance
			b:lock instance must be multithread shared instance, otherwise lock is invalid
			c: in synchonized clock block or synchonized method, when calling sleep(), it won't release lock instance,
			if calling wait(), it will release lock instance
		
******************************************************
package cn.itcast_05;

public class MyThread extends Thread {
//	public MyThread(String name) {
//		super(name);
//	}
	@Override
	public  void run() {
		for (int i = 0; i < 100; ++i) {
			System.out.println(Thread.currentThread().getName()+":"+i);
		}
	}
}

package cn.itcast_05;

public class MyThreadTest {

	public static void main(String[] args) {
		MyThread myThread1 = new MyThread();
		MyThread myThread2 = new MyThread();
		MyThread myThread3 = new MyThread();
		
		myThread1.setName("Lin Qingxia");
		myThread2.setName("Sun Li");
		myThread3.setName("Jiang Wenli");
		
		myThread1.start();
		myThread2.start();
		myThread3.start();
	}
}


***************************************************************************
package cn.itcast_05;

public class MyThread extends Thread {
	
	public MyThread(String name) {
		super(name);
	}
	@Override
	public  void run() {
		for (int i = 0; i < 100; ++i) {
			System.out.println(Thread.currentThread().getName()+":"+i);
		}
	}
}

package cn.itcast_05;

public class MyThreadTest {

	public static void main(String[] args) {
		MyThread myThread1 = new MyThread("Lin Qingxia");
		MyThread myThread2 = new MyThread("Sun Li");
		MyThread myThread3 = new MyThread("Jiang Wenli");
//		
//		myThread1.setName("Lin Qingxia");
//		myThread2.setName("Sun Li");
//		myThread3.setName("Jiang Wenli");
		
		myThread1.start();
		myThread2.start();
		myThread3.start();
	}
}

*****************************************************************************
package cn.itcast_05;

public class MyRunnable implements Runnable {

	@Override
	public void run() {
		for (int i = 0; i < 100; ++i) {
			System.out.println(Thread.currentThread().getName()+":"+i);
		}
	}
}

package cn.itcast_05;

public class MyRunnableTest {

	public static void main(String[] args) {
		MyRunnable myRunnable = new MyRunnable();
		Thread t1 = new Thread(myRunnable, "Lin Qingxia");
		Thread t2 = new Thread(myRunnable, "Sun Li");
		Thread t3 = new Thread(myRunnable, "Jiang Wenli");
		t1.start();
		t2.start();
		t3.start();
	}
}

*****************************************************************************
junit(unit test framework)

Current issue:
	a: all methods should be called in main()
	b: Results should be checked manually
	
https://junit.org/junit5/docs/current/api/
https://junit.org/junit5/docs/current/user-guide/index.pdf
https://github.com/junit-team/junit5/

A: download junit-*.*.jar on the internet
B: create Folder lib in the current project
C: right click on the jar->Build Path->Add Build Path->
   Then Referenced Libraries generated automatically

Notice:
	A: If we test one method by junit, green junit bar shows test case passes
	B: If we test one method by junit, red junit bar shows test case fails
	C: If you click on method name, class name, package name, project name, then run JUnit Test, it will run
	   all classes's test method, class, package, project and project all test method
	D: @Test method should not be static and shouldn't has formal parameter lists
	

junit using rules:
	A: If one class need be tested, the class is related to one test class
		test case name: (class name tested) +Test.
	B: one tested method is related to one test method
		test method name: test+(tested method name)
**********************************************************************************************
package cn.itcast_06;

import java.util.Arrays;

import org.junit.Test;

public class SortTest {
	@Test
	public void sort() {
		int[] arr = {10, 2, 20, 3, 5};
		
		for (int i = 0; i < arr.length - 1; ++i) {
			for (int j = i + 1; j < arr.length; ++j) {
				if (arr[i] > arr[j]) {
					int temp = arr[i];
					arr[i] = arr[j];
					arr[j] = temp;
				}
			}
		}
		System.out.println(Arrays.toString(arr));
	}
}

result:
[2, 3, 5, 10, 20]
**************************************************************************************************
1-Whatever method you want to test, you can choose the method name then click on Run as->JUnit Test,
only the chosen method is tested
2-If you want to test whole class, you can choose the test class name 
3-If you want to test whole package, you should choose the tested package
4-If you want to test whole project, you should choose the tested project
**************************************************************************************************
package cn.itcast_06;

import java.util.Arrays;

import org.junit.Test;

public class SortTest {
	@Test
	public void sort() {
		int[] arr = {10, 2, 20, 3, 5};
		
		for (int i = 0; i < arr.length - 1; ++i) {
			for (int j = i + 1; j < arr.length; ++j) {
				if (arr[i] > arr[j]) {
					int temp = arr[i];
					arr[i] = arr[j];
					arr[j] = temp;
				}
			}
		}
		System.out.println(Arrays.toString(arr));
	}
	
	@Test
	public void getMax() {
		int a = 10;
		int b = 20;
		int max =  (a > b) ? a : b;
		System.out.println("max value is "+max);
	}
}

result:
max value is 20 for getMax
[2, 3, 5, 10, 20] for sort
************************************************************************

However, we should divide product code and test code into two different files

************************************************************************
package cn.itcast_07;

public class Tool {
	public int getMax(int a, int b) {
		return a > b ? a : b;
	}

	public int getMin(int a, int b) {
		return a < b ? a : b;
	}
}

package cn.itcast_07;

import org.junit.Test;

public class ToolTest {
	@Test
	public void testGetMax() {
		int a = 3;
		int b = 5;
		int max = new Tool().getMax(a, b);
		System.out.println("max value:"+max);
	}
	
	@Test
	public void testGetMin() {
		int a = 3;
		int b = 5;
		int min = new Tool().getMin(a, b);
		System.out.println("min value:"+min);
	}
}

result:
max value:5
min value:3
***************************************************************************
Assert.assertSame
Assert.assertNotSame
Assert.assertEquals
Assert.assertNull
Assert.assertNotNull
Assert.assertTrue
Assert.assertFalse
******************************************************************************
package cn.itcast_06;

public class Tool {
	public int getMax(int a, int b) {
		return a > b ? a : b;
	}
	
	public int getMin(int a, int b) {
		return a < b ? a : b;
	}

}

package cn.itcast_06;

import org.junit.jupiter.api.Test;

import junit.framework.Assert;


public class ToolTest {
	@Test
	public void testGetMax() {
		int a = 3;
		int b = 5;
		int actual = new Tool().getMax(a, b);
		Assert.assertSame(5, actual);// ==: address
		Assert.assertNotSame("abc", new String("abc"));
//		Assert.assertSame(new String("abc"), "abc"); // ==, red
		Assert.assertEquals(new String("abc"), "abc"); // String equals, green
	}
	
	@Test
	public void testGetMin() {
		int a = 3;
		int b = 5;
		int actual = new Tool().getMin(a, b);
		int expected = 3;
		Assert.assertSame(expected, actual);
		
		Assert.assertNull(null);
		Assert.assertNotNull("abc");
		
		Assert.assertFalse( 5 == 6);
		Assert.assertTrue(2 == 2);
	}
}
**********************************************************************
@Before: before each tested method, many times
@After: after each tested method, many times
@BeforeClass: before all tested methods, once
@AfterClass: after all tested methods, once
***********************************************************************
package cn.itcast_07;

import java.io.FileInputStream;
import java.io.IOException;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class ReadFile {
	@Before
	public void prepareEnvironment() {
		System.out.println("Environment is ready...");
	}
	
	@Test
	public void FileRead() throws IOException {
		FileInputStream fis = new FileInputStream("a.txt");
		int content = 0;
		while ((content = fis.read()) != -1) {
			System.out.println((char)content);
		}
		fis.close();
	}
	
	@Test
	public void sort() {
		System.out.println("Sort");
	}
	
	@After
	public void clearEnvironment() {
		System.out.println("Environment is clear...");
	}

}


result:
Environment is ready...
a
b
c
Environment is clear...
Environment is ready...
Sort
Environment is clear...

******************************************
package cn.itcast_07;

import java.io.FileInputStream;
import java.io.IOException;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

public class ReadFile {
	@BeforeClass
	public static void prepareEnvironment() {
		System.out.println("Environment is ready...");
	}
	
	@Test
	public void FileRead() throws IOException {
		FileInputStream fis = new FileInputStream("a.txt");
		int content = 0;
		while ((content = fis.read()) != -1) {
			System.out.println((char)content);
		}
		fis.close();
	}
	
	@Test
	public void sort() {
		System.out.println("Sort");
	}
	
	@AfterClass
	public static void clearEnvironment() {
		System.out.println("Environment is clear...");
	}

}

Environment is ready...
a
b
c
Sort
Environment is clear...
****************************************************
Introspector: 内省--一种变态的反射
内省主要解决的问题是：把对象的属性值封装到对象中
**************************************************************8

package cn.itcast_08;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import org.junit.Test;


public class IntrospectorTest {
	@Test
	// get all get method name
	public void getAllProperties() throws IntrospectionException {
		BeanInfo info = Introspector.getBeanInfo(Person.class);
		PropertyDescriptor[] descriptors = info.getPropertyDescriptors();
		for (PropertyDescriptor descriptor : descriptors) {
			System.out.println(descriptor.getReadMethod());
		}
		
		
	}
	

	@Test
	// for class with many data members, it is not suitable
	public void testProperty() throws IntrospectionException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		Person person = new Person();
		PropertyDescriptor descriptorId = new PropertyDescriptor("id", Person.class);
		Method setId = descriptorId.getWriteMethod();
		setId.invoke(person, 100);
		Method getId = descriptorId.getReadMethod();
		System.out.println(getId.invoke(person, null));
		
		PropertyDescriptor descriptorName = new PropertyDescriptor("name", Person.class);
		Method setName = descriptorName.getWriteMethod();
		setName.invoke(person, "Andy");
		Method getName = descriptorName.getReadMethod();
		System.out.println(getName.invoke(person, null));
	}
}

result：
100
Andy
public final native java.lang.Class java.lang.Object.getClass()
public int cn.itcast_08.Person.getId()
public java.lang.String cn.itcast_08.Person.getName()
***************************************************************************

Apache BeanUtils
*************************************************
Download BeanUtils on the internet
copy it to lib folder
Add build path
**********************************************************
BeanUtils: 把对象的属性值封装到对象中，
但是更简单

