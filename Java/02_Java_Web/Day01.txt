Single column:
Collection: Single column collection root interface
----| List: ordered, repeated
  --------| ArrayList: based on Object instance array, find fast(memory address is continuous), add and delete slow(copy all)
  --------| Vector: based on Object instance array, but thread-safe
  --------| LinkedList: based on linked list, find slow, add and delete fast
----| Set: unordered, unrepeated
  --------| HashSet: based on hash table, store and get fast
              hashCode() and equals()
              When adding elements into HashSet, call hashCode() at first to get the hash code value,
              then compute the location of elements according to hash code value;
              If the location computed has not existed any elements, add it into hash table directly
              If the location computed has existed one element, call equals() to compare the new element and the element on the location
                If equals() return true, it is considered repeated element, and not add it into hash table
                If equals() return false, add it into hash table directly
               
              default hashCode() means the address of instance
              default equals() means two instances has the same address
              
  --------| TreeSet:

Double column:

************************************************
HashSet practice
***********************************************
Situation 1:
***********************************************
package cn.itcast_01;

public class Person {
	int id;
	String name;
	
	public Person(int id, String name) {
		this.id = id;
		this.name = name;
	}

	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + "]";
	}
}
package cn.itcast_01;

import java.util.HashSet;

public class HashSetTest {

	public static void main(String[] args) {
		HashSet<Person> hs = new HashSet<Person>();
		hs.add(new Person(100, "Lily"));
		hs.add(new Person(100, "Lily"));
		System.out.println(hs);
	}
}

result:
[Person [id=100, name=Lily], Person [id=100, name=Lily]]
***************************************************************
Situation 2:
***************************************************************
package cn.itcast_02;

public class Person {
	int id;
	String name;
	
	public Person(int id, String name) {
		this.id = id;
		this.name = name;
	}

	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + id;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Person other = (Person) obj;
		if (id != other.id)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}
}

package cn.itcast_02;

import java.util.HashSet;

public class HashSetTest {

	public static void main(String[] args) {
		HashSet<Person> hs = new HashSet<Person>();
		hs.add(new Person(100, "Lily"));
		hs.add(new Person(100, "Lily"));
		System.out.println(hs);
	}
}

result:
[Person [id=100, name=Lily]]
**************************************************************
