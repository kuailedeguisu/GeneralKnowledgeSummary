1. Why does Regular expression generate?
Check QQ number
req:
A: 5 to 15 digits
B: don't begin with 0
*******************
package cn.itcast_01;

import java.util.Scanner;

public class RegexTest1 {

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		System.out.println("Please enter your QQ number(5 to 15 digits):");
		String str = scanner.nextLine();
		boolean bl = isQQNumber(str);
		boolean bl1 = checkQQ(str);
		System.out.println("isQQNumber:"+bl);
		System.out.println("checkQQ:"+bl1);
		

	}
	
	// My implementation:
	public static boolean isQQNumber(String str) {
		char[] chs = str.toCharArray();
		int count = 0;
		boolean flag = true;
		
		for (int i = 0; i < chs.length; ++i) {
			if (!Character.isDigit(chs[i])) {
				flag = false;
				break;
			}
			else {
				count++;
			}
			
			if (chs[0] == '0') {
				flag = false;
				
			}
		}
		
		if (count < 5 || count > 15) {
			return false;
		}
		
		return flag;
	}
	
	// Teacher method, recommended
	public static boolean checkQQ(String qq) {
		boolean flag = true;
		
		if (qq.length() >= 5 && qq.length() <= 15) {
			if (!qq.startsWith("0")) {
				char[] chs = qq.toCharArray();
				for (int i = 0; i < chs.length; ++i) {
					char ch = chs[i];
					if (!Character.isDigit(ch)) {
						flag = false;
						break;
					}
				}
			}
			else {
				flag = false;
			}
		}
		else {
			flag = false;
		}
		
		return flag;
	}

}
***********************************
It is very completed for the simple requirement, so we need to use another method.

Regex: String with a rule
********************
Use Regex:
package cn.itcast_01;

import java.util.Scanner;

public class RegexTest2 {

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		System.out.println("Please enter your QQ number(5 to 15 digits):");
		String str = scanner.nextLine();
		boolean isQQ = checkQQ(str);
		System.out.println("checkQQ:"+isQQ);
	}
	
	public static boolean checkQQ(String qq) {
		return qq.matches("[1-9][0-9]{4,14}");
	}

}
***************************

2. Pattern
java.util.regex
class Pattern
*: the items we must master
char
Characters
x	The character x       *
\\	The backslash character           *
\0n	The character with octal value 0n (0 <= n <= 7)
\0nn	The character with octal value 0nn (0 <= n <= 7)
\0mnn	The character with octal value 0mnn (0 <= m <= 3, 0 <= n <= 7)
\xhh	The character with hexadecimal value 0xhh
\uhhhh	The character with hexadecimal value 0xhhhh
\x{h...h}	The character with hexadecimal value 0xh...h (Character.MIN_CODE_POINT  <= 0xh...h <=  Character.MAX_CODE_POINT)
\N{name}	The character with Unicode character name 'name'
\t	The tab character ('\u0009')
\n	The newline (line feed) character ('\u000A')        *
\r	The carriage-return character ('\u000D')            *
\f	The form-feed character ('\u000C')
\a	The alert (bell) character ('\u0007')
\e	The escape character ('\u001B')

Character classes
[abc]	a, b, or c (simple class)       *
[^abc]	Any character except a, b, or c (negation)      *
[a-zA-Z]	a through z or A through Z, inclusive (range) *
[0-9]           0 through 9                 *
[a-d[m-p]]	a through d, or m through p: [a-dm-p] (union)
[a-z&&[def]]	d, e, or f (intersection)
[a-z&&[^bc]]	a through z, except for b and c: [ad-z] (subtraction)
[a-z&&[^m-p]]	a through z, and not m through p: [a-lq-z](subtraction)

Predefined character classes
.	Any character (may or may not match line terminators)     *
\.       .                                                        *
\d	A digit: [0-9]                                            *
"\\d"      A digit: [0-9]                                         *
\D	A non-digit: [^0-9]                                *
\h	A horizontal whitespace character: [ \t\xA0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000]
\H	A non-horizontal whitespace character: [^\h]
\s	A whitespace character: [ \t\n\x0B\f\r]           *
\S	A non-whitespace character: [^\s]
\v	A vertical whitespace character: [\n\x0B\f\r\x85\u2028\u2029]
\V	A non-vertical whitespace character: [^\v]
\w	A word character: [a-zA-Z_0-9]           *(In the regex, the thing which consist of word must be so)
\W	A non-word character: [^\w]

POSIX character classes (US-ASCII only)
\p{Lower}	A lower-case alphabetic character: [a-z]
\p{Upper}	An upper-case alphabetic character:[A-Z]
\p{ASCII}	All ASCII:[\x00-\x7F]
\p{Alpha}	An alphabetic character:[\p{Lower}\p{Upper}]
\p{Digit}	A decimal digit: [0-9]
\p{Alnum}	An alphanumeric character:[\p{Alpha}\p{Digit}]
\p{Punct}	Punctuation: One of !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
\p{Graph}	A visible character: [\p{Alnum}\p{Punct}]
\p{Print}	A printable character: [\p{Graph}\x20]
\p{Blank}	A space or a tab: [ \t]
\p{Cntrl}	A control character: [\x00-\x1F\x7F]
\p{XDigit}	A hexadecimal digit: [0-9a-fA-F]
\p{Space}	A whitespace character: [ \t\n\x0B\f\r]
java.lang.Character classes (simple java character type)
\p{javaLowerCase}	Equivalent to java.lang.Character.isLowerCase()
\p{javaUpperCase}	Equivalent to java.lang.Character.isUpperCase()
\p{javaWhitespace}	Equivalent to java.lang.Character.isWhitespace()
\p{javaMirrored}	Equivalent to java.lang.Character.isMirrored()
Classes for Unicode scripts, blocks, categories and binary properties
\p{IsLatin}	A Latin script character (script)
\p{InGreek}	A character in the Greek block (block)
\p{Lu}	An uppercase letter (category)
\p{IsAlphabetic}	An alphabetic character (binary property)
\p{Sc}	A currency symbol
\P{InGreek}	Any character except one in the Greek block (negation)
[\p{L}&&[^\p{Lu}]]	Any letter except an uppercase letter (subtraction)


Boundary matchers
^	The beginning of a line                           *
$	The end of a line                                 *
\b	A word boundary                                   * (the location which is not word char)
\b{g}	A Unicode extended grapheme cluster boundary
\B	A non-word boundary
\A	The beginning of the input
\G	The end of the previous match
\Z	The end of the input but for the final terminator, if any
\z	The end of the input
Linebreak matcher
\R	Any Unicode linebreak sequence, is equivalent to \u000D\u000A|[\u000A\u000B\u000C\u000D\u0085\u2028\u2029]
Unicode Extended Grapheme matcher
\X	Any Unicode extended grapheme cluster
Greedy quantifiers
X?	X, once or not at all        * [01]
X*	X, zero or more times        * [01+]
X+	X, one or more times         *. [1+]
X{n}	X, exactly n times           *
X{n,}	X, at least n times          *
X{n,m}	X, at least n but not more than m times  *


Reluctant quantifiers
X??	X, once or not at all
X*?	X, zero or more times
X+?	X, one or more times
X{n}?	X, exactly n times
X{n,}?	X, at least n times
X{n,m}?	X, at least n but not more than m times


Possessive quantifiers
X?+	X, once or not at all
X*+	X, zero or more times
X++	X, one or more times
X{n}+	X, exactly n times
X{n,}+	X, at least n times
X{n,m}+	X, at least n but not more than m times
Logical operators
XY	X followed by Y
X|Y	Either X or Y
(X)	X, as a capturing group
Back references
\n	Whatever the nth capturing group matched
\k<name>	Whatever the named-capturing group "name" matched
Quotation
\	Nothing, but quotes the following character
\Q	Nothing, but quotes all characters until \E
\E	Nothing, but ends quoting started by \Q
Special constructs (named-capturing and non-capturing)
(?<name>X)	X, as a named-capturing group
(?:X)	X, as a non-capturing group
(?idmsuxU-idmsuxU) 	Nothing, but turns match flags i d m s u x U on - off
(?idmsux-idmsux:X)  	X, as a non-capturing group with the given flags i d m s u x on - off
(?=X)	X, via zero-width positive lookahead
(?!X)	X, via zero-width negative lookahead
(?<=X)	X, via zero-width positive lookbehind
(?<!X)	X, via zero-width negative lookbehind
(?>X)	X, as an independent, non-capturing group
\cx	The control character corresponding to x

3. Pattern judge function
String matches
public boolean matches(String regex);
***************************************
matches
public boolean matches​(String regex)
Tells whether or not this string matches the given regular expression.
An invocation of this method of the form str.matches(regex) yields exactly the same result as the expression

Pattern.matches(regex, str)
Parameters:
regex - the regular expression to which this string is to be matched
Returns:
true if, and only if, this string matches the given regular expression
Throws:
PatternSyntaxException - if the regular expression's syntax is invalid
*********************************
package cn.itcast_01;

import java.util.Scanner;
import java.util.regex.Pattern;

public class PhoneNumberTest {

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		System.out.println("Please enter the mobile phone number:");
		String string = scanner.nextLine();
		boolean flag1 = string.matches("1[378]\\d{9}");
		boolean flag2 = Pattern.matches("1[378]\\d{9}", string);
		System.out.println("String matches:"+flag1);
		System.out.println("Pattern matches:"+flag2);
	}
}

result:
Please enter the mobile phone number:
18912345678
String matches:true
Pattern matches:true
**********************************
check email
**************
package cn.itcast_01;

import java.util.Scanner;

public class EmailTest {

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		System.out.println("Please enter an email:");
		String emailString = scanner.nextLine();
		String regexString = "\\w+@\\w+{2,6}(\\.\\w{2,3})+";
		boolean flag1 = emailString.matches(regexString);
		System.out.println(flag1);

	}

}

result:
123@itcast.com.cn
true
*****************************
**************************


4. Regex split function
String
split
public String[] split​(String regex)
Splits this string around matches of the given regular expression.
This method works as if by invoking the two-argument split method with the given expression and a limit argument of zero. Trailing empty strings are therefore not included in the resulting array.

The string "boo:and:foo", for example, yields the following results with these expressions:

Regex	Result
:	{ "boo", "and", "foo" }
o	{ "b", "", ":and:f" }
Parameters:
regex - the delimiting regular expression
Returns:
the array of strings computed by splitting this string around matches of the given regular expression
Throws:
PatternSyntaxException - if the regular expression's syntax is invalid
***************************
Check if your age meets the requirements:
package cn.itcast_01;

import java.util.Scanner;

public class RegexTest3 {

	public static void main(String[] args) {
		String ageString = "18-24";
		String[] strings = ageString.split("-");
		int begin = Integer.parseInt(strings[0]);
		int end = Integer.parseInt(strings[1]);
		
		Scanner scanner = new Scanner(System.in);
		System.out.println("Please enter your age[18-24]:");
		int age = scanner.nextInt();
		
		if (age >= begin && age <= end) {
			System.out.println("In the range");
		}
		else {
			System.out.println("Out of the range");
		}

	}

}
**************************

package cn.itcast_01;

public class RegexSplit2 {

	public static void main(String[] args) {
		String str1 = "aa,bb,cc";
		String[] strings1 = str1.split(",");
		for (int i = 0; i < strings1.length; ++i) {
			System.out.println(strings1[i]);
		}
		System.out.println("---------------");
		
		String str2 = "aa.bb.cc";
		String[] strings2 = str2.split("\\.");
		for (int i = 0; i < strings2.length; ++i) {
			System.out.println(strings2[i]);
		}
		System.out.println("---------------");
		
		String str3 = "aa   bb                  cc";
		String[] strings3 = str3.split(" +");
		for (int i = 0; i < strings3.length; ++i) {
			System.out.println(strings3[i]);
		}
		System.out.println("---------------");
		
		String str4 = "E:\\develop\\java\\src";
		String[] strings4 = str4.split("\\\\");
		for (int i = 0; i < strings4.length; ++i) {
			System.out.println(strings4[i]);
		}
		System.out.println("---------------");

	}

}

result:
aa
bb
cc
---------------
aa
bb
cc
---------------
aa
bb
cc
---------------
E:
develop
java
src
---------------

***************************************
Sort one String:
package cn.itcast_01;

import java.util.Arrays;

public class RegexSort {

	public static void main(String[] args) {
		String string = "12 34 78 1 2 89";
		String regexString = " +";
		String[] splitStrings = string.split(regexString);
		
		int[] intArray = new int[splitStrings.length];
		for (int i=0; i < splitStrings.length; ++i) {
			intArray[i] = Integer.parseInt(splitStrings[i]);
		}
		
		Arrays.sort(intArray);
		
		StringBuilder sBuffer = new StringBuilder();
		for (int i=0; i < intArray.length; ++i) {
			sBuffer.append(intArray[i]).append(" ");
		}
		
		String newString = sBuffer.toString().trim();
		System.out.println("result: "+newString);
	}
}

result:
result:1 2 12 34 78 89
***********************
***********************************

5. Regex replace
String
replaceAll
public String replaceAll​(String regex, String replacement)
Replaces each substring of this string that matches the given regular expression with the given replacement.
An invocation of this method of the form str.replaceAll(regex, repl) yields exactly the same result as the expression

Pattern.compile(regex).matcher(str).replaceAll(repl)
Note that backslashes (\) and dollar signs ($) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string; see Matcher.replaceAll. Use Matcher.quoteReplacement(java.lang.String) to suppress the special meaning of these characters, if desired.

Parameters:
regex - the regular expression to which this string is to be matched
replacement - the string to be substituted for each match
Returns:
The resulting String
Throws:
PatternSyntaxException - if the regular expression's syntax is invalid
***********************
package cn.itcast_01;

public class RegexReplace {

	public static void main(String[] args) {
		String string = "qwerqq1234567kh622112345678xxxx";
		String regexString = "\\d";
//		String regexString = "\\d+"// * to replace all numbers
		String replaceString = "*";
		String replaceString2 = "";
		String resultString = string.replaceAll(regexString, replaceString);
		String resultString2 = string.replaceAll(regexString, replaceString2);
		System.out.println(resultString);
		System.out.println(resultString2);
	}

}

result:
qwerqq*******kh************xxxx
qwerqqkhxxxx
*******************************************

6. Regex get function
Pattern and Matcher

 Pattern p = Pattern.compile("a*b");
 Matcher m = p.matcher("aaaaab");
 boolean b = m.matches();
 
 ****************************
 \b: A word boundary
 
 Please get word with three letters
 
 package cn.itcast_01;

import java.util.regex.Pattern;

import java.util.regex.Matcher;

public class RegexGet {

	public static void main(String[] args) {
		String ss = "wo ai guo jia, wo zhen de ai guo jia";
		Pattern pattern = Pattern.compile("\\b\\w{3}\\b");
		Matcher m = pattern.matcher(ss);
		
//		Before using Matcher.group(), we must call Matcher.find()
		while(m.find()) {
			System.out.println(m.group());
		}
	}
}
result:
guo
jia
guo
jia
*********************

*******************
