1. Collection
Collection(single column)
	List(ordered and duplicated)
		ArrayList:based on Array, fast to find, slow to add and remove, thread-unsafe, high efficiency
		Vector:based on Array, fast to find, slow to add and remove, thread-safe, low efficiency
		LinkedList: based on linked table, slow to find, fast to add and remove, thread-unsafe, high efficiency
	Set(unique and unordered)
		HashSet
			based on hash table
			hash table is based on hashCode() and equals()
			steps:
				A: Whether hashCode() are the same
					A1: yes
						A11: run equals(),return
							A111: true? not add the element
							A112: false? add the element
					A2: no
						A21: add the element
			At last: use hashCode() and equals() generated automatically
			LinkedHashSet
				based on hash table and linked table
				hash table to keep element unique
				linked table to keep element ordered
		TreeSet
			based on red-black tree, which is a auto-balanced binary tree
			how to keep element unique?
				whether comparator returns 0 or not
			how to keep element ordered?
				two methods:
					natural sort(element)
						let the Class owning element implement Comparable interface
					comparator sort(Collection)
						let Collection receive a Comparator implementation Class Object
			
			
Map(two columns, key and value)
	Map is only valid for key, not related to value
	store pairs of key and value, key is unique, value is duplicated
	HashMap
			based on hash table, thread-unsafe, high efficiency
			hash table is based on hashCode() and equals()
			steps:
				A: Whether hashCode() are the same
					A1: yes
						A11: run equals(),return
							A111: true? not add the element
							A112: false? add the element
					A2: no
						A21: add the element
			At last: use hashCode() and equals() generated automatically
			LinkedHashSet
				based on hash table and linked table
				hash table to keep element unique
				linked table to keep element ordered
		LinkedHashMap
	Hashtable
			based on hash table, thread-safe, low efficiency
			hash table is based on hashCode() and equals()
			steps:
				A: Whether hashCode() are the same
					A1: yes
						A11: run equals(),return
							A111: true? not add the element
							A112: false? add the element
					A2: no
						A21: add the element
			At last: use hashCode() and equals() generated automatically
		
	TreeMap
			based on red-black tree, which is a auto-balanced binary tree
			how to keep element unique?
				whether comparator returns 0 or not
			how to keep element ordered?
				two methods:
					natural sort(element)
						let the Class owning element implement Comparable interface
					comparator sort(Collection)
						let Collection receive a Comparator implementation Class Object

2. Which Collection should we use?
	Requirements
	Whether it is pair Object of key and value?
		Yes?
			Map
				Key need by ordered?
					Yes? TreeMap
					No? HashMap(*)
			    Don't know about it, use HashMap
		No?
			Collection
				element is unique?
					yes?
						Set
							element need be ordered?
								yes? TreeSet
								no?  HashSet(*)
					no?
						List
							safe?
								yes?
									Vector(we don't use it)
								no?
									ArrayList or LinkedList?
										more find? ArrayList(*)
										more add or delete? LinkedList
				Don't know about it, use ArrayList	
				
3. common traverse methods for Collection and Map
Collection:
	add()
	remove()
	contains()
	iterator()
	size()
	traverse:
		enhance for
		iterator
	|-List
		get()
		traverse:
			common for
			enhance for
			iterator
	|-Set
		
Map:
	put()
	remove()
	containsKey()
	keySet()
	get()
	value()
	entrySet()
	size()
	
	traverse:
		key to find value: keySet()+get()
		pair of key and value to get key and value: entrySet()+Entry.getKey()+Entry.getValue()

4. ArrayList, LinkedList. HashSet, HashMap(master)
	store String and custom Object and traverse

5. Collection nesting traverse

///////////////////////////////////////////////
IO stream
*******************************************
register and login system
*******************************************
client:
	login system
		username
		password
		login
		reset
	register system
		username
		password
		register
		cancel
		
server:
	data storage:
		table
		Class
	function implementation

Steps:
	register:
		enter username and pasword, submit it to server, server store the data
		if data is right, return true, else, return false
	login:
		enter username and password, submit it to server, server find it in data storage,
		if matched, return true, else, return false

***********************************
Matchmaking website
**********************************
client:
	register
		name
		age
		sex 
			male
			female
		picture
		browser(d:\\love\mn.jpg)
		register
		cancel
	find
		find all users pictures
		user1
		user2
		user3 picture has something wrong
		......
		

Server:
	register: upload operation
		IO read client data and write it into server
		picture has something wrong
	find: download operation(choose download tool)
		IO read server data and show them on client

************************************************
Abnormal
file
Recursive 
Byte Stream 
Conversion flow 
Character Stream 
Other streams 


Exception
Exception: program has some abnormal situations
Program Exception: Throwable
	serious issues: Error(we don't handle, such as memory overflow)
	issues: Exception
		compilation period Exception: all Exception not RuntimeException(we must handle, not go through compilation)
		runtime period Exception:     RuntimeException(We don't handle, caused by code,  The code is not rigorous)

Exception
public class Exception
extends Throwable
The class Exception and its subclasses are a form of Throwable 
that indicates conditions that a reasonable application might want to catch.
The class Exception and any subclasses that are not also subclasses 
of RuntimeException are checked exceptions. 
Checked exceptions need to be declared in a method or constructor's throws clause 
if they can be thrown by the execution of the method or constructor 
and propagate outside the method or constructor boundary.

Throwable
public class Throwable
extends Object
implements Serializable
The Throwable class is the superclass of all errors and exceptions in the Java language.
Instances of two subclasses, Error and Exception, 
are conventionally used to indicate that exceptional situations have occurred.
Typically, these instances are freshly created 
in the context of the exceptional situation so as to include relevant information 
(such as stack trace data). 


Error
public class Error
extends Throwable
An Error is a subclass of Throwable that indicates serious problems 
that a reasonable application should not try to catch. 
Most such errors are abnormal conditions. The ThreadDeath error, 
though a "normal" condition, is also a subclass of Error because 
most applications should not try to catch it. 


JVM how to handle Exception?
If we don't handle Exception, JVM will start default Exception handling:
output Exception name, cause and issue information on console, 
and end the program and not go on the following code lines

handle Exception:
	A: try...catch...finally
	B: throws
	
	method 1:
	try {
		the codes which have potential Exception
	} catch(ExceptionName variable) {
		handle the Exception
	} finally {
		release resources
	}

	method 2:
		try {
		the codes which have potential Exception
	} catch(ExceptionName variable) {
		handle the Exception
	}


Note: as less as possible for codes in try {}

*****************************************************
package cn.itcast_01;

public class ExceptionDemo {

	public static void main(String[] args) {
		int a = 10;
//		int b = 2;
		int b = 0; // java.lang.ArithmeticException
		try {
			System.out.println(a / b); 
		} catch (ArithmeticException e) {
			System.out.println("One integer can't be divided by zero");
		}
		
		System.out.println("Over!");
	}
}

result:
One integer can't be divided by zero
Over!
**********************************************


Two methods to handle exception
1-try…catch…finally
2-throws

try {
	code with potential exception 
} catch(ExceptionName variableName) {
	handle exception
} finally {
	release resource
}

try {
	code with potential exception 
} catch(ExceptionName variableName) {
	handle exception
} 

Note: as less as possible for code in try
**********************************
package cn.itcast_01;


public class ExceptionTest01 {

	public static void main(String[] args) {
		int a = 10;
		int b = 0;
		
		try {
			System.out.println(a/b);
		} catch(ArithmeticException e) {
			System.out.println("One integer is not divided by zero");
			
		}
		System.out.println("Over!");
	}
}

Result:
One integer is not divided by zero
Over!
******************************
Try..multiple catch…Issue:
If one Exception encounters, other code after the code who throws the Exception are not run, it will go into the related catch, 
other catch can’t be run
Once try has one issue, it will throw one Exception, then match the Exception with catch, once one catch matched, execute the statements in
The matched catch, then end try, then run the coming statements after try
If you know the specified Exception, you need write the specified ones and put it as front as possible; if you don’t know which Exception it is,
We should add Exception catch statement, which can catch any sub Exception; if you put Exception in the first place, any other sub Exception can’t be added, if you do so, compilation error will generate
The same level Exception has no order, but father Exception should be after sub Exception
***************************
One try
More catch

package cn.itcast_01;


public class ExceptionTest01 {

	public static void main(String[] args) {
		int a = 10;
		int b = 0;
		int[] arr = { 1, 2, 3 };

		try {
			System.out.println(a / b);
			System.out.println(arr[3]);
		} catch (ArithmeticException e) {
			System.out.println("One integer is not divided by zero");
		} catch (ArrayIndexOutOfBoundsException ee) {
			System.out.println("Array index is out of bounds");
		}

//
//		try {
//			System.out.println(arr[3]);
//			
//		} catch (ArrayIndexOutOfBoundsException ee) {
//			System.out.println("Array index is out of bounds");
//		}

		System.out.println("Over!");
	}
}

Result:
One integer is not divided by zero
Over!
***************************************************
More than one try…catch…, too repeated

package cn.itcast_01;


public class ExceptionTest01 {

	public static void main(String[] args) {
		int a = 10;
		int b = 0;
		int[] arr = { 1, 2, 3 };

		try {
			System.out.println(a / b);
		} catch (ArithmeticException e) {
			System.out.println("One integer is not divided by zero");
		}


		try {
			System.out.println(arr[3]);
			
		} catch (ArrayIndexOutOfBoundsException ee) {
			System.out.println("Array index is out of bounds");
		}

		System.out.println("Over!");
	}
}


Result:
One integer is not divided by zero
Array index is out of bounds
Over!
*****************************
Unknown Exception will exist
Exception can match any sub Exception
package cn.itcast_01;

import java.util.Hashtable;

public class ExceptionTest01 {

	public static void main(String[] args) {
		int a = 10;
		int b = 20;
		int[] arr = {1, 2, 3};

		try {
			System.out.println(a / b);
			System.out.println(arr[2]);
			Hashtable<String, String> hashtable = new Hashtable<String, String>();
			hashtable.put(null, null);
		} catch (ArithmeticException e) {
			System.out.println("One integer is not divided by zero");
		} catch (ArrayIndexOutOfBoundsException ee) {
			System.out.println("Array index is out of bounds");
		} catch (Exception e) {
			System.out.println("Here an Exception");
		}

		System.out.println("Over!");
	}
}

Result:
0
3
Here an Exception
Over!
*******************
JDK 7 new feature:
Try {
} catch(Exception1 | Exception2 | … ee) {
}

But 
Try {
} catch(Exception1 | Exception2 | …|Exception ee) {
}
Not permitted

All Exception should be the same level
******************************************
package cn.itcast_01;

import java.util.Hashtable;

public class ExceptionTest3 {

	public static void main(String[] args) {
		int a = 10;
		int b = 20;
		int[] arr = {1, 2, 3};

		try {
			System.out.println(a / b);
			System.out.println(arr[3]);
			Hashtable<String, String> hashtable = new Hashtable<String, String>();
			hashtable.put(null, null);
		} catch (ArithmeticException | ArrayIndexOutOfBoundsException e) {
			System.out.println("sub Exception");
		} catch (Exception e) {
			System.out.println("Here an Exception");
		}

		System.out.println("Over!");
	}
}
********************************************
The difference between compilation Exception and runtimeException
**************
Match, don’t throw ParseException

package cn.itcast_01;


import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class CompilationExceptionTest01 {

	public static void main(String[] args) {
		String string = "2019-07-16";
		SimpleDateFormat dFormat = new SimpleDateFormat("yyyy-MM-dd");
		try {
			Date date = dFormat.parse(string);
			System.out.println(date);
		} catch (ParseException e) {
			e.printStackTrace();
		}
	}
}

Result:
Tue Jul 16 00:00:00 CST 2019
****************************************************
String has no HH:mm:ss

package cn.itcast_01;


import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class CompilationExceptionTest01 {

	public static void main(String[] args) {
		String string = "2019-07-16";
		SimpleDateFormat dFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		try {
			Date date = dFormat.parse(string);
			System.out.println(date);
		} catch (ParseException e) {
			e.printStackTrace();
		}
	}
}

Result:
java.text.ParseException
*************************************
Only match yyyy-MM-dd, don’t care about extra String

package cn.itcast_01;


import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class CompilationExceptionTest01 {

	public static void main(String[] args) {
		String string = "2019-07-16--";
		SimpleDateFormat dFormat = new SimpleDateFormat("yyyy-MM-dd");
		try {
			Date date = dFormat.parse(string);
			System.out.println(date);
		} catch (ParseException e) {
			e.printStackTrace();
		}
	}
}

Result:
Tue Jul 16 00:00:00 CST 2019
******************************************
java.lang.Object
java.lang.Throwable
java.lang.Exception
java.text.ParseException
*******************************
Throws Exception
It should be after method()
package cn.itcast_01;


import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class CompilationExceptionTest01 {

	public static void main(String[] args) throws ParseException {
		String string = "2019-07-16--";
		SimpleDateFormat dFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		Date date = dFormat.parse(string);
		System.out.println(date);
//		try {
//			Date date = dFormat.parse(string);
//			System.out.println(date);
//		} catch (ParseException e) {
//			e.printStackTrace();
//		}
	}
}

Result:
Exception in thread "main" java.text.ParseException: Unparseable date: "2019-07-16--"
	at java.base/java.text.DateFormat.parse(DateFormat.java:395)
	at cn.itcast_01.CompilationExceptionTest01.main(CompilationExceptionTest01.java:13)
***************************************************************************************************************
Throwable methods:
public String getMessage()
public void printStackTrace()
public void printStackTrace (PrintStream s) // Write it into one file
public String toString()
	Returns a short description of this throwable. The result is the concatenation of:
        * the name of the class of this object
        * ": " (a colon and a space)
        * the result of invoking this object's getLocalizedMessage() method

*****************************
package cn.itcast_01;


import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class CompilationExceptionTest01 {

	public static void main(String[] args) {
		String string = "2019-07-16";
		SimpleDateFormat dFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		
		try {
			Date date = dFormat.parse(string);
			System.out.println(date);
		} catch (ParseException e) {
			System.out.println(e.getMessage());
//			e.printStackTrace();
		}
	}
}

Result:
Unparseable date: "2019-07-16"
*********************************************************
package cn.itcast_01;


import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class CompilationExceptionTest01 {

	public static void main(String[] args) {
		String string = "2019-07-16";
		SimpleDateFormat dFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		
		try {
			Date date = dFormat.parse(string);
			System.out.println(date);
		} catch (ParseException e) {
//			System.out.println(e.getMessage());
//			e.printStackTrace();
			System.out.println(e.toString());
		}
	}
}

Result:
java.text.ParseException: Unparseable date: "2019-07-16"
***************************************
package cn.itcast_01;


import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class CompilationExceptionTest01 {

	public static void main(String[] args) {
		String string = "2019-07-16";
		SimpleDateFormat dFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		
		try {
			Date date = dFormat.parse(string);
			System.out.println(date);
		} catch (ParseException e) {
//			System.out.println(e.getMessage());
			e.printStackTrace();
//			System.out.println(e.toString());
		}
	}
}

Result in red:
java.text.ParseException: Unparseable date: "2019-07-16"
	at java.base/java.text.DateFormat.parse(DateFormat.java:395)
	at cn.itcast_01.CompilationExceptionTest01.main(CompilationExceptionTest01.java:15)
**********************************************************************
package cn.itcast_01;

,m
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class CompilationExceptionTest01 {

	public static void main(String[] args) {
		String string = "2019-07-16";
		SimpleDateFormat dFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		
		try {
			Date date = dFormat.parse(string);
			System.out.println(date);
		} catch (ParseException e) {
//			System.out.println(e.getMessage());
//			e.printStackTrace();
//			System.out.println(e.toString());
			e.printStackTrace(System.out); // write it into console
		}
	}
}

Result not in red:
java.text.ParseException: Unparseable date: "2019-07-16"
	at java.base/java.text.DateFormat.parse(DateFormat.java:395)
	at cn.itcast_01.CompilationExceptionTest01.main(CompilationExceptionTest01.java:15)
*****************************************************************
Throws ExceptionClassName

Put after method()

When we have no ability to handle Exception, we only need throw it and handle it in caller method

Note: 
	1-Try not to throw Exception on main method, we can throw Exception on called method, then handle it on main method
	2-But it is only for compilation exception, if it is runtime exception, we don’t need throw on called method and handle it on main method
***************************************************************
package cn.itcast_01;

import java.text.ParseException;
import java.text.SimpleDateFormat;


public class CompilationExceptionThrowsTest {

	public static void main(String[] args) {
		System.out.println("Begin method");
		try {
			method(); // we need handle compilation exception, otherwise, compilation failed
		} catch (ParseException e) {
			e.printStackTrace();
		}
		System.out.println("End method");
		
		// we don't need handle runtime Exception if we want to make compilation pass
		System.out.println("Begin method2");
		method2();
		System.out.println("End method2");
	}

	// Runtime Exception
	public static void method2() throws ArithmeticException {
		int a = 10;
		int b = 0;
		System.out.println(a/b);
	}

	// Compilation Exception
	public static void method() throws ParseException {
		String string = "2019-07-16";
		SimpleDateFormat dFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		dFormat.parse(string);
	}
}


Result:
Begin method
java.text.ParseException: Unparseable date: "2019-07-16"
	at java.base/java.text.DateFormat.parse(DateFormat.java:395)
	at cn.itcast_01.CompilationExceptionThrowsTest.method(CompilationExceptionThrowsTest.java:35)
	at cn.itcast_01.CompilationExceptionThrowsTest.main(CompilationExceptionThrowsTest.java:12)
End method
Begin method2
Exception in thread "main" java.lang.ArithmeticException: / by zero
	at cn.itcast_01.CompilationExceptionThrowsTest.method2(CompilationExceptionThrowsTest.java:28)
	at cn.itcast_01.CompilationExceptionThrowsTest.main(CompilationExceptionThrowsTest.java:20)
******************************************
Note:
	Compilation Exception: caller must handle it
	Runtime Exception: caller can not handle it
We can throw multiple Exception by the following method
... method(...) throws Exception1, Exception2,...

**************************************************************
package cn.itcast_01;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class ExceptionDemo02 {

	public static void main(String[] args) {
		try {
			method();
		} catch (ParseException e) {
			e.printStackTrace();
		}
		
		try {
			method2();
		} catch (ArithmeticException e) {
			e.printStackTrace();
		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	public static void method2() throws ArithmeticException, Exception {
		int a = 10;
		int b = 0;
		
		System.out.println(a / b);
	}

	public static void method() throws ParseException {
		String string = "2019-07-17";
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
		Date d = sdf.parse(string);
	}
}


result:
java.lang.ArithmeticException: / by zero
	at cn.itcast_01.ExceptionDemo02.method2(ExceptionDemo02.java:30)
	at cn.itcast_01.ExceptionDemo02.main(ExceptionDemo02.java:17)
***********************************************************************
The differences between throw and throws
	throw: if exception exists, we can throw Exception Object inside method
		A: Used inside the method body, after it, Exception Object
		B: Only throw one Exception Object
		C:throw Exception, then handle it by statements inside the method
		D: throw show throw Exception, execute throw, it must throw one Exception
	throws: if exception exists, we can throw Exception after method()
		A: used after method definition, after it, Exception Class name
		B: multiple Exception Class names can be used, and use "," to seperate them
		C: throws only show the possibility to generate Exception, not sure if it will happen
	
	
************************************************************
package cn.itcast_01;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class ExceptionThrowTest01 {

	public static void main(String[] args) {
//		method();
		try {
			method2();
		} catch (Exception e) {
			e.printStackTrace();
		}

	}

//	public static void method() {
//		int a = 10;
//		int b = 0;
//		
//		if (b == 0) {
//			throw new ArithmeticException();
//		} else {
//			System.out.println(a / b);
//		}
//	}
	
	public static void method2() throws Exception {
		int a = 10;
		int b = 0;
		
		if (b == 0) {
			throw new Exception();
		} else {
			System.out.println(a / b);
		}
	}

}

result:
java.lang.Exception
	at cn.itcast_01.ExceptionThrowTest01.method2(ExceptionThrowTest01.java:35)
	at cn.itcast_01.ExceptionThrowTest01.main(ExceptionThrowTest01.java:12)
**************************************************************
package cn.itcast_01;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class ExceptionThrowTest01 {

	public static void main(String[] args) {
		method();
//		try {
//			method2();
//		} catch (Exception e) {
//			e.printStackTrace();
//		}

	}

	public static void method() {
		int a = 10;
		int b = 0;
		
		if (b == 0) {
			throw new ArithmeticException();
		} else {
			System.out.println(a / b);
		}
	}
	
//	public static void method2() throws Exception {
//		int a = 10;
//		int b = 0;
//		
//		if (b == 0) {
//			throw new Exception();
//		} else {
//			System.out.println(a / b);
//		}
//	}

}

result:
Exception in thread "main" java.lang.ArithmeticException
	at cn.itcast_01.ExceptionThrowTest01.method(ExceptionThrowTest01.java:24)
	at cn.itcast_01.ExceptionThrowTest01.main(ExceptionThrowTest01.java:10)
*********************************************************************************

How to handle Exception:
principle: 
	A: If we can handle it inside method, use try; 
	B: If not, handle it by caller, use throws
Differences:
	A: The coming programs need run, use try
	B: The coming programs don't need run, use throws
*******************************************************************

finally
	A: try...catch...finally...
	B: All programs controlled by finally must be executed
	C: Note: 
		if before finally, jvm exit, finally won't be executed
		System.exit(0);
	D: purpose: release resources
*****************************************************
package cn.itcast_01;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class ExceptionFinallyTest {

	public static void main(String[] args) {
		String string = "2019-07-17";
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		Date d = null;
		try {
			d = sdf.parse(string);
		} catch (ParseException e) {
			e.printStackTrace();
		} finally {
			System.out.println(d);
		}

	}

}

result:
java.text.ParseException: Unparseable date: "2019-07-17"
	at java.base/java.text.DateFormat.parse(DateFormat.java:395)
	at cn.itcast_01.ExceptionFinallyTest.main(ExceptionFinallyTest.java:14)
null
*********************************************************
final, finally, finalize
	final: last, Class, member variable, member method
		Class: Class can't be inheritted
		member variable: variable is const
		member method:   method can't be overrided
	finally:
		Exception handling part, used in releasing resources,
		generally, it will be executed, but before it, program exit, is one exception
	finalize: Object method, used to garbage collecting
		Called by the garbage collector on an object when garbage collection determines 
		that there are no more references to the object.
		A subclass overrides the finalize method to dispose of system resources 
		or to perform other cleanup. 
********************************
before finally, return in catch
finally will be executed between the code before return in catch and return in catch
**********************************************
package cn.itcast_01;

public class FinallyTest01 {

	public static void main(String[] args) {

		System.out.println(method());
	}
	
	public static int method() {
		int a = 10;
		
		try {
			System.out.println(a / 0);
			a = 20;
		} catch (ArithmeticException e) {
			a = 30; // step 1 : a = 30
			return a; // step 3: return a=>return 30;
		} finally {
			a = 40; // step 2: a = 40
		}
		
		return a; // not executed
	}

}

result:
30
********************************
package cn.itcast_01;

public class FinallyTest01 {

	public static void main(String[] args) {

		System.out.println(method());
	}
	
	public static int method() {
		int a = 10;
		
		try {
			System.out.println(a / 0);
			a = 20;
		} catch (ArithmeticException e) {
			a = 30; // step 1 : a = 30
			return a; // don't be run
		} finally {
			a = 40; // step 2: a = 40
			return a; // step 3: return 40
		}
	}

}

result:
40
************************************************************

try...catch...finally format
	A: try...catch...finally
	B: try...catch
	C: try...catch...catch......
	D: try...catch...catch......finally
	E: try...finally
		used to release resources
	
custom Exception
Inheritted from 
	Exception
	RuntimeException

******************************************
MyException.java

package cn.itcast_01;

public class MyException extends Exception {

	public MyException() {
		super();
	}

	public MyException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
		super(message, cause, enableSuppression, writableStackTrace);
	}

	public MyException(String message, Throwable cause) {
		super(message, cause);
	}

	public MyException(String message) {
		super(message);
	}

	public MyException(Throwable cause) {
		super(cause);
	}

}


Teacher.java

package cn.itcast_01;

public class Teacher {
	public void check(int score) throws MyException {
		if (score >100 | score < 0) {
			throw new MyException("ScoreOutOfRange");
		} else {
			System.out.println("Your score is in the range");
		}
	}

}


TeacherTest.java

package cn.itcast_01;

import java.util.Scanner;

public class TeacherTest {

	public static void main(String[] args) {
		Teacher teacher = new Teacher();
		Scanner sc = new Scanner(System.in);
		System.out.println("Please enter your score[0-100]:");
		int score = sc.nextInt();
		try {
			teacher.check(score);
		} catch (MyException e) {
			e.printStackTrace();
		}

	}

}

**************************
Exception Notes:
	A: When a child class overrides a parent class's method, 
	   the child class's method must throw an exception like 
	   the parent class or a child class of a parent class exception. 
	   (Father is bad, subclass can't be worse) 
	B:  If a parent class throws more than one exception, 
		a child class can only throw the same exception or his child class 
		when it overrides a parent class method, and the child class cannot 
		throw an exception that the parent class does not have
	C:  If the overridden method is not thrown by an exception, then the subclass 
	    can never throw an exception, and if an exception occurs within the subclass method,
		then the subclass can only try, not throws 
	
	
********************************
Fu.java

package cn.itcast_02;

public abstract class Fu {
	public abstract void show() throws Exception;

}

Zi.java
package cn.itcast_02;

public class Zi extends Fu {
	public void show() throws ArithmeticException {
		
	}

}

**********************************************************
Fu.java

package cn.itcast_02;

public abstract class Fu {
	public abstract void show() throws Exception;
	public abstract void method();
}

Zi.java
package cn.itcast_02;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Zi extends Fu {
	public void show() throws ArithmeticException {
		
	}
	
	public void method() {
		String string = "2019-07-17";
		SimpleDateFormat sdf = new SimpleDateFormat();
		Date d = null;
		try {
			d = sdf.parse(string);
		} catch (ParseException e) {
			e.printStackTrace();
		}
	}

}
***********************************************


File
public class File
extends Object
implements Serializable, Comparable<File>

An abstract representation of file and directory pathnames. 


public File?(String pathname) // package one pathname into one File Object 
public File?(String parent,
            String child)
public File?(File parent,
            String child)

******************************************************
package cn.itcast_01;

import java.io.File;

public class FileTest01 {

	public static void main(String[] args) {
		File f1 = new File("c:\\develop\\a.txt");
		System.out.println("f: "+f1);
		
		File f2 = new File("c:\\develop", "a.txt");
		System.out.println("f2: "+f2);
		
		File f3 = new File(new File("c:\\develop"), "a.txt");
		System.out.println("f3: "+f3);

	}

}

result:
f: c:\develop\a.txt
f2: c:\develop\a.txt
f3: c:\develop\a.txt
********************************************

File Create File functions:
public boolean createNewFile()      // Create File based on existing directory
                      throws IOException // dir not existing, throws IOException
					        // if file exists, don't create it
public boolean mkdir()      // Create single layer directory
                            // if directory exists, don't create it
public boolean mkdirs()     // Create multiple layers directory
                            // If father directory doesn't exist, create it automatically
							// mkdirs to create file only create dir named fileName(don't use it to create file)


********************************************

package cn.itcast_02;

import java.io.File;
import java.io.IOException;

public class CreateFileTest {

	public static void main(String[] args) {
		File f1 = new File("c:\\demo");
		System.out.println(f1.mkdir()); // mkdir to create single layer dir
			
		File f2 = new File("c:\\demo\\test\\a.txt");
		try {
			System.out.println(f2.createNewFile());// create file based on dir existing
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		File f3 = new File("c:\\demo\\test");
		System.out.println("mkdir:"+f3.mkdir()); // mkdir to create single layer dir
		
		File f4 = new File("c:\\demo\\test\test1\test2");
		System.out.println("mkdir:"+f4.mkdir()); // mkdir to create single layer dir
		
		File f5 = new File("c:\\demo\\test\\test2\\test3\\test4");
		System.out.println("mkdirs:"+f5.mkdirs());// mkdirs to create multiple layers dir

	}
}

result:
true
java.io.IOException: The system cannot find the path specified
	at java.base/java.io.WinNTFileSystem.createFileExclusively(Native Method)
	at java.base/java.io.File.createNewFile(File.java:1024)
	at cn.itcast_02.CreateFileTest.main(CreateFileTest.java:14)
mkdir:true
mkdir:false
mkdirs:true


**************************************
File Delete functions
public boolean delete()

Note: 
	A: If you create file or file directory, forget to write directory, 
		the directory will be in java project
	B: Java delete don't run into recycling bin
	C: delete can delete one file or one directory
******************************
package cn.itcast_03;

import java.io.File;
import java.io.IOException;

public class FileTest {

	public static void main(String[] args) {
		File f1 = new File("a.txt");
		try {
			System.out.println(f1.createNewFile());
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		File f2 = new File("aaa\\bbb");
		System.out.println(f2.mkdirs());
		
		File f3 = new File("a.txt");
		System.out.println("delete:"+f3.delete());
		
		File f4 = new File("aaa\\bbb");
		System.out.println("delete directory:"+f4.delete());
		File f5 = new File("aaa");
		System.out.println("delete directory:"+f5.delete());
	}
}

result:
true
true
delete:true
delete directory:true
delete directory:true
***************************************
 Path starts with a disk character:           absolute path 
 Path does not start with a disk character:   relative path 
 
File rename functions:
public boolean renameTo?(File dest) // Renames the file denoted by this abstract pathname. 
									// dir is the same, rename the file
									// dir is not the same, cut the file

**********************************************
package cn.itcast_04;

import java.io.File;
import java.io.IOException;

public class FileRenameTest {

	public static void main(String[] args) {
		File f1 = new File("lingqingxia.jpg");
		File newFile1 = new File("dongfangbubai.jpg");
		try {
			System.out.println(f1.createNewFile());
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		System.out.println("rename f1:"+f1.renameTo(newFile1));
		
		
		File f2 = new File("lingqingxia.jpg");
		File f3 = new File("c:\\demo");
		System.out.println("mkdir f3:"+f3.mkdir());
		File newFile2 = new File("c:\\\\demo\\dongfangbubai.jpg");
		try {
			System.out.println(f2.createNewFile());
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		System.out.println(f2.renameTo(newFile2));

	}

}

result:
true
rename f1:true
mkdir f3:true
true
true

project dir: dongfangbubai.jpg
c:\\demo: dongfangbubai.jpg
****************************************************************

File judge functions:
public boolean isDirectory()
public boolean isFile()
public boolean isHidden()
public boolean canRead()
public boolean canWrite()
public boolean exists()

**************************************
package cn.itcast_05;

import java.io.File;
import java.io.IOException;

public class FileJudgeTest {

	public static void main(String[] args) throws IOException {
		File f1 = new File("a.txt");
		System.out.println(f1.createNewFile());
		System.out.println("isDirectory:"+f1.isDirectory());
		System.out.println("isFile:"+f1.isFile());
		System.out.println("exists:"+f1.exists());
		System.out.println("canRead:"+f1.canRead());
		System.out.println("canWrite:"+f1.canWrite());
		System.out.println("isHidden:"+f1.isHidden());

	}
}

result:
true
isDirectory:false
isFile:true
exists:true
canRead:true
canWrite:true
isHidden:false
*****************************
Note: 
	We can click read-only or hide to change canWrite or isHidden return value

***********************************************************
File Get functions:
public String getAbsolutePath() // get absolute path
public String getPath()         // get relative path
public long length()            // get length, bytes
public long lastModified()      // get last modified time, Milliseconds 
public String getName()

*********************************************************
package cn.itcast_06;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;

public class FileGetTest {

	public static void main(String[] args) {
		File f1 = new File("a.txt");
		System.out.println("getAbsolutePath: "+f1.getAbsolutePath());
		System.out.println("getPath: "+f1.getPath());
		System.out.println("length: "+f1.length());
		
		System.out.println("lastModified: "+f1.lastModified());
		long ms = f1.lastModified();
		Date d = new Date(ms);
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		System.out.println("lastModified time:"+sdf.format(d));

		System.out.println("getName: "+f1.getName());

	}

}

result:
getAbsolutePath: C:\Users\xx\eclipse_new_workspace\day19_File\a.txt
getPath: a.txt
length: 47
lastModified: 1563353142809
lastModified time:2019-07-17 16:45:42
Wed Jul 17 16:45:42 CST 2019
getName: a.txt
***************************************************
File advanced get functions:
public String[] list()    //  Get an array of names for all files or folders in the specified directory 
public File[] listFiles() //  Get an array of Files for all files or folders in the specified directory 

********************************************
package cn.itcast_06;

import java.io.File;

public class FileAdvancedGetTest {

	public static void main(String[] args) {
		File f1 = new File("c:\\develop");
		String[] strArr = f1.list();
		System.out.println("Names array:");
		for (String string : strArr) {
			System.out.println(string);
		}
		System.out.println("-------------------");
		System.out.println("Files array:");
		File[] fileArr = f1.listFiles();
		for (File f : fileArr) {
			System.out.println(f);
		}
	}
}

result:
Names array:
code
eclipse
FromTeacher
Java
java_??
java_??.zip
JDK_API_1_6_zh_CN.CHM
preferences.epf
resource.zip
software
-------------------
Files array:
c:\develop\code
c:\develop\eclipse
c:\develop\FromTeacher
c:\develop\Java
c:\develop\java_??
c:\develop\java_??.zip
c:\develop\JDK_API_1_6_zh_CN.CHM
c:\develop\preferences.epf
c:\develop\resource.zip
c:\develop\software
*********************************************

Requirement: judge whether there are some jpg files in special dir
Note: You only can get file names in the special dir not including its sub dirs
Methods:
	A: get all files, then traverse all files, for each file, judge if it is a file, then judge if it ends with .jpg
	B: When getting file, you will know if it meets the conditions
************************************************************
method 1: A

package cn.itcast_07;

import java.io.File;

public class JudgeFileTypeTest {

	public static void main(String[] args) {
		File f = new File("c:\\demo");
		File[] files = f.listFiles();
		
		for (File file : files) {
			if (file.isFile()) {
				if (file.getName().endsWith(".jpg")) {
					System.out.println(file.getName());
				}
				
			}
		}
	}

}


result:
dongfangbubai.jpg
************************************************************************

public String[] list?(FilenameFilter filter)
public File[] listFiles?(FilenameFilter filter)

**********************************************************
Method 2: B

package cn.itcast_07;

import java.io.File;
import java.io.FilenameFilter;

public class JudgeFileTypeTest02 {

	public static void main(String[] args) {
		File f = new File("c:\\demo");
		String[] strArr = f.list(new FilenameFilter() {
			
			public boolean accept(File dir, String name) {
				return new File(dir, name).isFile() && name.endsWith(".txt");
			}
		});
		
		for (String string : strArr) {
			System.out.println(string);
		}

	}

}

result:
a.txt
**************************************************************************
Requirement: rename all files in special dir
conditions: file location
	c:\demo\test\sanguoyanyi_001_jintianhengaoxing_lvbuhuidiaochan.txt
	c:\demo\test\sanguoyanyi_002_jintianhengaoxing_sanbumaolv.txt
	c:\demo\test\sanguoyanyi_003_jintianhengaoxing_zaochuanjiejian.txt
	c:\demo\test\sanguoyanyi_004_jintianhengaoxing_taoyansanjieyi.txt
rename format: 001_lvbuhuidiaochan.txt
*****************************************************************
import java.io.File;

public class FilesRenameTest {

	public static void main(String[] args) {
		File f = new File("c:\\demo\\test");
		String[] files = f.list();
		
		for (String string : files) {
			int index = string.indexOf("_");
			String firstString =  string.substring(index + 1, index + 4);
			
			int startIndex = string.lastIndexOf("_");
			int endIndex = string.lastIndexOf(".");
			String secondString = string.substring(startIndex + 1, endIndex);
			
			String lastString = firstString.concat("_").concat(secondString);
			System.out.println(lastString);
			
		}

	}

}


result:
001_lvbuhuidiaochan
002_sanbumaolv
003_zaochuanjiejian
004_taoyansanjieyi
****************************************************************
	
	
