1.StringBuffer
public final class StringBuffer
extends Object
implements Serializable, Comparable<StringBuffer>, CharSequence
A thread-safe, mutable sequence of characters. A string buffer is like a String, but can be modified. 
At any point in time it contains some particular sequence of characters, but the length and content of the sequence 
can be changed through certain method calls.
String buffers are safe for use by multiple threads. The methods are synchronized where necessary 
so that all the operations on any particular instance behave as if they occur in some serial order 
that is consistent with the order of the method calls made by each of the individual threads involved.

The principal operations on a StringBuffer are the append and insert methods, which are overloaded 
so as to accept data of any type. Each effectively converts a given datum to a string and then 
appends or inserts the characters of that string to the string buffer. The append method always 
adds these characters at the end of the buffer; the insert method adds the characters at a specified point.
-----------------------------------------------------------
thread-safe: sync(data can't be operated at the same time, safe)
thread-unsafe:not sync(efficiently)
You only have safety or efficience.We only can consider one item according to the situation.
bank:               safe
news and internet:  efficience
---------------------------------------------------------
StringBuffer: thread-safe, mutable sequene
The difference between StringBuffer and String:
StringBuffer: length and content of it are changed, String appending will not waste a lot of memory
String: length and content of it are not changed, String appending will waste a lot of memory
----------------------
StringBuffer constructor methods:
StringBuffer()	
Constructs a string buffer with no characters in it and an initial capacity of 16 characters.
StringBuffer​(int capacity)	
Constructs a string buffer with no characters in it and the specified initial capacity.
StringBuffer​(CharSequence seq)	
Constructs a string buffer that contains the same characters as the specified CharSequence.
StringBuffer​(String str)	
Constructs a string buffer initialized to the contents of the specified string.
--------------------
CharSequence
Interface CharSequence
All Known Subinterfaces:
Name
All Known Implementing Classes:
CharBuffer, Segment, String, StringBuffer, StringBuilder
-------------------
public StringBuffer(String str) {
        super(str.length() + 16);
        append(str);
    }
    --------------
StringBuffer member methods:
capacity: theorical value
public int capacity()
Returns the current capacity. The capacity is the amount of storage available for newly inserted characters, beyond which an allocation will occur.
Returns:
the current capacity

length: actural value
int length()
Returns the length of this character sequence. The length is the number of 16-bit chars in the sequence.
Returns:
the number of chars in this sequence


1. StringBuffer add function:
1) append
// We can append any data types of data into StringBuffer
// and return the StringBuffer itself

java.lang.AbstractStringBuilder 	append​(boolean b) 	
Appends the string representation of the boolean argument to the sequence.

java.lang.AbstractStringBuilder 	append​(char c) 	
Appends the string representation of the char argument to this sequence.

java.lang.AbstractStringBuilder 	append​(char[] str) 	
Appends the string representation of the char array argument to this sequence.

java.lang.AbstractStringBuilder 	append​(double d) 	
Appends the string representation of the double argument to this sequence.

java.lang.AbstractStringBuilder 	append​(float f) 	
Appends the string representation of the float argument to this sequence.

java.lang.AbstractStringBuilder 	append​(int i) 	
Appends the string representation of the int argument to this sequence.

java.lang.AbstractStringBuilder 	append​(long l) 	
Appends the string representation of the long argument to this sequence.

java.lang.AbstractStringBuilder 	append​(Object obj) 	
Appends the string representation of the Object argument.

java.lang.AbstractStringBuilder 	append​(String str) 	
Appends the specified string to this character sequence.

StringBuffer 	append​(char[] str, int offset, int len) 	
Appends the string representation of a subarray of the char array argument to this sequence.

StringBuffer 	append​(CharSequence s) 	
Appends the specified CharSequence to this sequence.

StringBuffer 	append​(CharSequence s, int start, int end) 	
Appends a subsequence of the specified CharSequence to this sequence.

StringBuffer 	append​(StringBuffer sb) 	
Appends the specified StringBuffer to this sequence.

StringBuffer 	appendCodePoint​(int codePoint) 	
Appends the string representation of the codePoint argument to this sequence.
/////////////////////////////
package cn.itcast_01;

public class StringBufferAddTest1 {

	public static void main(String[] args) {
		StringBuffer sb = new StringBuffer();
//		Method1: Check addresses
//		StringBuffer sb2 = sb.append("hello");
//		System.out.println(sb);// "hello"
//		System.out.println(sb2);// "hello"
//		System.out.println(sb == sb2);// true
		
//		Method2: append step to step
//		sb.append("hello");
//		sb.append(10);
//		sb.append(true);
//		sb.append(10.9);
//		System.out.println(sb);

//		Method3: link coding
		sb.append("hello").append(10).append(true).append(123.456);
		System.out.println(sb);
		
	}
}
////////////////////////////////////////



2) insert
// Insert any data genre of data in the specified index
// The original elements will be moved to after the inserted string

StringBuffer 	insert​(int offset, boolean b) 	
Inserts the string representation of the boolean argument into this sequence.

StringBuffer 	insert​(int offset, char c) 	
Inserts the string representation of the char argument into this sequence.

StringBuffer 	insert​(int offset, char[] str) 	
Inserts the string representation of the char array argument into this sequence.

StringBuffer 	insert​(int index, char[] str, int offset, int len) 	
Inserts the string representation of a subarray of the str array argument into this sequence.

StringBuffer 	insert​(int offset, double d) 	
Inserts the string representation of the double argument into this sequence.

StringBuffer 	insert​(int offset, float f) 	
Inserts the string representation of the float argument into this sequence.

StringBuffer 	insert​(int offset, int i) 	
Inserts the string representation of the second int argument into this sequence.

StringBuffer 	insert​(int offset, long l) 	
Inserts the string representation of the long argument into this sequence.

StringBuffer 	insert​(int dstOffset, CharSequence s) 	
Inserts the specified CharSequence into this sequence.

StringBuffer 	insert​(int dstOffset, CharSequence s, int start, int end) 	
Inserts a subsequence of the specified CharSequence into this sequence.

StringBuffer 	insert​(int offset, Object obj) 	
Inserts the string representation of the Object argument into this character sequence.

StringBuffer 	insert​(int offset, String str) 	
Inserts the string into this character sequence.

////////////////////////
package cn.itcast_01;

public class StringBufferInsertTest {

	public static void main(String[] args) {
		StringBuffer sb = new StringBuffer();
		sb.append("hello").append("world").append(true).append(123.456);
		sb.insert(5, "big").insert(13, "itis");
		System.out.println(sb);

	}

}
/////////////////////////
2. StringBuffer delete function
StringBuffer 	delete​(int start, int end) 	
Removes the characters in a substring of this sequence.

StringBuffer 	deleteCharAt​(int index) 	
Removes the char at the specified position in this sequence.

///////////////////
package cn.itcast_01;

public class StringBufferDeleteTest {

	public static void main(String[] args) {
		StringBuffer sb = new StringBuffer();
		sb.append("hello").append("world").append(true).append(123.456);
		System.out.println(sb); // "helloworldtrue123.456"
		sb.deleteCharAt(0);
		System.out.println(sb); // "elloworldtrue123.456"
		sb.delete(0, 4);
		System.out.println(sb); // "worldtrue123.456"
		sb.delete(0, sb.length());
		System.out.println(sb); // ""
	}

}
//////////////////////////////////

3. StringBuffer replace function
StringBuffer 	replace​(int start, int end, String str) 	
Replaces the characters in a substring of this sequence with characters in the specified String.
-------------------------
package cn.itcast_01;

public class StringBufferReplaceTest {

	public static void main(String[] args) {
		StringBuffer sb = new StringBuffer();
		sb.append("helloworld").append(true).append(100).append(123.456);
		System.out.println(sb);
		sb.replace(10, 14, "false");
		System.out.println(sb);
		sb.replace(10, 15, "true");
		System.out.println(sb);

	}

}
-----------------------------
4. StringBuffer reverse function
StringBuffer 	reverse() 	
Causes this character sequence to be replaced by the reverse of the sequence.
--------------------------------
package cn.itcast_01;

public class StringBufferReverseTest {

	public static void main(String[] args) {
		StringBuffer sb = new StringBuffer();
		sb.append("helloworld").append(true).append(1998);
		System.out.println(sb);
		sb.reverse();
		System.out.println(sb);
	}

}
--------------------------------------

5. StringBuffer substring function
// Return String instead of StringBuffer
// It won't return StringBuffer itself

String 	substring​(int start) 	
Returns a new String that contains a subsequence of characters currently 
contained in this character sequence.

String 	substring​(int start, int end) 	
Returns a new String that contains a subsequence of characters currently 
contained in this sequence.

---------------------------
package cn.itcast_01;

public class StringBufferSubstringTest {

	public static void main(String[] args) {
		StringBuffer sb = new StringBuffer();
		sb.append("helloworld").append("hellosky").append(true);
		System.out.println(sb);
		StringBuffer sb2 = new StringBuffer(sb.substring(10));
		System.out.println(sb);
		System.out.println(sb2);

	}

}
----------------------------------
6. StringBuffer and String convert
class A->class B: use class B methods
class B->class A: because we need return class A 
String can't be assiged to StringBuffer
Any reference type of data can be converted into String by means of toString()

--------------------------
package cn.itcast_01;

public class StringBufferStringConvertTest {

	public static void main(String[] args) {
//		String->StringBuffer
//		method1: StringBuffer constructor method
		String str = "hello";
		StringBuffer sb = new StringBuffer(str);
		System.out.println(sb);

//		method2: StringBuffer append method
		StringBuffer sb1 = new StringBuffer();
		sb1.append(str);
		System.out.println(sb1);
		
//		StringBuffer->String
//		method1: String constructor
		StringBuffer sb2 = new StringBuffer("HelloSkyHelloWorld");
		String str2 = new String(sb2);
		System.out.println(sb2);
		System.out.println(str2);
		
//		method2 ： substring
		StringBuffer sb3 = new StringBuffer("helloworldhelosky");
		String str3 = sb3.substring(0);
		System.out.println(sb3);
		System.out.println(str3);
		
//		method3: toString
		StringBuffer sb4 = new StringBuffer("StudyHard");
		String str4 = sb4.toString();
		System.out.println(sb4);
		System.out.println(str4);
	}

}
------------------------------------------


7. Joint an array into a String
Recommend method 2: use the same memory
---------------------------------
package cn.itcast_01;

public class ArrayJointToStringTest {

	public static void main(String[] args) {
		int arr[] = {1, 2, 3, 4, 5, 6};
		System.out.println(arrayToString(arr));
		System.out.println(arrayToString2(arr));

	}
	
//	method 1: String
	public static String arrayToString(int[] arr) {
		int len = arr.length;
		
		String result = "";
		
		result += "[";
		
		for (int i = 0; i < len; ++i) {
			if (i == len -1) {
				result += arr[i];
				result += "]";
			} else {
				result += arr[i];
				result += ", ";
			}
		}
		
		return result;
	}
	
// method 2: StringBuffer
	public static String arrayToString2(int[] arr) {
		int len = arr.length;
		
		StringBuffer sb = new StringBuffer();
		String result;
		
		sb.append("[");
		
		for (int i = 0; i < len; ++i) {
			if (i == len -1) {
				sb.append(arr[i]).append("]");
			} else {
				sb.append(arr[i]).append(", ");
			}
		}
		
		result = new String(sb);
		
		return result;
	}

}

result:
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
---------------------------------------------

8. reverse String
-------------------------------------------
package cn.itcast_01;

public class StringReverseTest {

	public static void main(String[] args) {
		String str = "HelloWorld!";
		System.out.println(reverseString1(str));
		System.out.println(reverseString2(str));
		System.out.println(reverseString3(str));
	}
	
//	method 1 : length() and charAt()
	public static String reverseString1(String str) {
		int len = str.length();
		String result = "";
		
		for (int i=0; i < len; ++i) {
			result += str.charAt(len - 1 - i);
		}
		
		return result;
		
	}
	
//	method 2 : toCharArray()
	public static String reverseString2(String str) {
		char[] chs = str.toCharArray();
		String result = "";
		
		for (int i=0; i < chs.length; ++i) {
			result += chs[chs.length - 1 - i];
		}
		
		return result;
		
	}
	
	
//	method 3: StringBuffer()
	public static String reverseString3(String str) {
		return new StringBuffer(str).reverse().toString();
		
	}

}

result:
!dlroWolleH
!dlroWolleH
!dlroWolleH
-----------------------

9. Judge whether one String is symmetric
----------------------------------------------
package cn.itcast_01;

import java.util.Scanner;

public class StringSymmetryTest {

	public static void main(String[] args) {	
		Scanner sc = new Scanner(System.in);
		System.out.println("Please enter a string");
		String enteredStr = sc.nextLine();
		System.out.println(isStringSymmetry1(enteredStr));
		System.out.println(isStringSymmetry2(enteredStr));
		System.out.println(isStringSymmetry3(enteredStr));
		System.out.println(isStringSymmetry4(enteredStr));

	}
	
//	method 1: length() and charAt()
	public static boolean isStringSymmetry1(String str) {
		int len = str.length();
		
		for (int i=0; i < len/2; ++i ) {
			if (str.charAt(i) != str.charAt(len - 1 - i)) {
				return false;
			}
		}
		
		return true;
	}


//	method 2: StringBuffer reverse()
	public static boolean isStringSymmetry2(String str) {
		return new StringBuffer(str).reverse().toString().equals(str);
	}
	
//	method 3:toCharArray()
	public static boolean isStringSymmetry3(String str) {
		boolean flag = true;
		char[] chs = str.toCharArray();
		
		for (int i=0; i < chs.length; ++i ) {
			if (chs[i] != chs[chs.length - 1 - i]) {
				flag = false;
				break;
			}
		}
		
		return flag;
	}
	
//	method 4:toCharArray(), start, end
	public static boolean isStringSymmetry4(String str) {
		char[] chs = str.toCharArray();
		
		for (int start = 0, end = chs.length - 1; start <= end; start++, end--) {
			if (chs[start] != chs[end]) {
				return false;
			}
		}
		
		return true;
	}
}
------------------------------------------------------------

10. The differences among String, StringBuffer, StringBuilder
A: String's contents are not changed, while StringBuffer's and StringBuilder's
contents are changed
B: StringBuffer is thread-safe(synced), data is safe but not efficient.
StringBuilder is not thread-safe(not synced), data is not safe but efficent


Class StringBuilder

    java.lang.Object
        java.lang.StringBuilder 

    All Implemented Interfaces:
        Serializable, Appendable, CharSequence

    public final class StringBuilder
    extends Object
    implements Serializable, CharSequence

    A mutable sequence of characters. This class provides an API compatible with 
	StringBuffer, but with no guarantee of synchronization. 
	This class is designed for use as a drop-in replacement 
	for StringBuffer in places where the string buffer was 
	being used by a single thread (as is generally the case). 
	Where possible, it is recommended that this class be used in 
	preference to StringBuffer as it will be faster under most implementations.

    The principal operations on a StringBuilder are the append and insert methods, 
	which are overloaded so as to accept data of any type. Each effectively 
	converts a given datum to a string and then appends or inserts the characters 
	of that string to the string builder. The append method always adds these 
	characters at the end of the builder; the insert method adds the characters 
	at a specified point.

    For example, if z refers to a string builder object whose current contents are "start",
	then the method call z.append("le") would cause the string builder to contain "startle",
	whereas z.insert(4, "le") would alter the string builder to contain "starlet".

    In general, if sb refers to an instance of a StringBuilder, then sb.append(x) has the 
	same effect as sb.insert(sb.length(), x).

    Every string builder has a capacity. As long as the length of the character sequence 
	contained in the string builder does not exceed the capacity, it is not necessary to 
	allocate a new internal buffer. If the internal buffer overflows, it is automatically 
	made larger.

    Instances of StringBuilder are not safe for use by multiple threads. 
	If such synchronization is required then it is recommended that StringBuffer be used.

    Unless otherwise noted, passing a null argument to a constructor or method 
	in this class will cause a NullPointerException to be thrown.
	
11. The differences between StringBuffer and Array
A: Both of them are containers, store other data.
B: StringBuffer only can contain String data;
Array can contain any type of data, but all data elements in one Array must be the same.

12. String and StringBuffer as the formal parameter of one method
formal parameter:
basic type: the change of formal parameters won't change actural parameters
reference type: the change of formal parameters will change actural parameters

We can use debug pattern to see what's happened.
F6: move to next step
F5: step into the called method, then use F6 to move to the next step in the called method

String as formal parameter of one method, it is the same as basic type
StringBuffer as formal parameter of one method, we only can change actural parameter when calling 
StringBuffer method, such as append(), insert(), etc.


13. Array sort and find
Array sort: we can see the video for each Array sort
--------------------------
BubbleSort
--------------------------
package cn.itcast;

/*
 * 冒泡排序基本概念是：
 * 依次比较相邻的两个数，将小数放在前面，大数放在后面。
 * 即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。
 * 然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，
 * 直至比较最后两个数，将小数放前，大数放后。至此第一趟结束，
 * 将最大的数放到了最后。在第二趟：仍从第一对数开始比较
 * （因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数），
 * 将小数放前，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是最大的），
 * 第二趟结束，在倒数第二的位置上得到一个新的最大数
 * （其实在整个数列中是第二大的数）。如此下去，重复以上过程，直至最终完成排序。 
 */
public class BubbleSort {
	public static void sort(int[] data) {
		for (int i = 0; i < data.length - 1; i++) {
			for (int j = 0; j < data.length - 1 - i; j++) {
				if (data[j] > data[j + 1]) {
					SortTest.swap(data, j, j + 1);
				}
			}
		}
	}
}

--------------------------
HeapSort
--------------------------
package cn.itcast;

public class HeapSort {
	public static void sort(int[] data) {
		MaxHeap h = new MaxHeap();
		h.init(data);
		for (int i = 0; i < data.length; i++)
			h.remove();
		System.arraycopy(h.queue, 1, data, 0, data.length);
	}

	private static class MaxHeap {

		void init(int[] data) {
			this.queue = new int[data.length + 1];
			for (int i = 0; i < data.length; i++) {
				queue[++size] = data[i];
				fixUp(size);
			}
		}

		private int size = 0;

		private int[] queue;

		public int get() {
			return queue[1];

		}

		public void remove() {
			SortTest.swap(queue, 1, size--);
			fixDown(1);
		}

		// fixdown
		private void fixDown(int k) {
			int j;
			while ((j = k << 1) <= size) {
				if (j < size && queue[j] < queue[j + 1])
					j++;
				if (queue[k] > queue[j]) // 不用交换

					break;
				SortTest.swap(queue, j, k);
				k = j;
			}
		}

		private void fixUp(int k) {
			while (k > 1) {
				int j = k >> 1;
				if (queue[j] > queue[k])
					break;
				SortTest.swap(queue, j, k);

				k = j;
			}
		}

	}
}
/*
 * 堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征， 使得在当前无序区中选取最大（或最小）关键字的记录变得简单。 　　
 * （1）用大根堆排序的基本思想 　　 ① 先将初始文件R[1..n]建成一个大根堆，此堆为初始的无序区 　　 ②
 * 再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个 记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，
 * 且满足R[1..n-1].keys≤R[n].key 　　 ③由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。
 * 然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，
 * 由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，
 * 且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。 　 直到无序区只有一个元素为止。 　　
 * （2）大根堆排序算法的基本操作： 　　 ① 初始化操作：将R[1..n]构造为初始堆； 　　 ②
 * 每一趟排序的基本操作：将当前无序区的堆顶记录R[1]和该区间的最后一个记录交换， 然后将新的无序区调整为堆（亦称重建堆）。
 */
 
 
--------------------------
InsertSort
--------------------------
 package cn.itcast;

/*
 * 插入排序基本思想
 * 将n个元素的数列分为已有序和无序两个部分，如插入排序过程示例下所示： 　　
 * {{a1}，{a2，a3，a4，…，an}} 　　
 * {{a1⑴，a2⑴}，{a3⑴，a4⑴ …，an⑴}} 　
 * {{a1(n-1），a2(n-1) ，…},{an(n-1)}} 　　
 * 每次处理就是将无序数列的第一个元素与有序数列的元素从后往前逐个进行比较，
 * 找出插入位置，将该元素插入到有序数列的合适位置中。
 */
public class InsertSort {
	public static void sort(int[] data) {
		for (int i = 1; i < data.length; i++) {
			for (int j = i; (j > 0) && (data[j] < data[j - 1]); j--) {
				SortTest.swap(data, j, j - 1);
			}
		}

	}
}


--------------------------
MergeSort
--------------------------
package cn.itcast;

/*
 * 归并操作(merge)，也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。 　　
 * 如设有数列{6，202，100，301，38，8，1} 　　
 * 初始状态： [6] [202] [100] [301] [38] [8] [1] 比较次数 　　
 * i=1 [6 202 ] [ 100 301] [ 8 38] [ 1 ]　3 　　
 * i=2 [ 6 100 202 301 ] [ 1 8 38 ]　4 　　
 * i=3　[ 1 6 8 38 100 202 301 ] 4 
 */
public class MergeSort {
	public static void sort(int[] data) {
		int[] temp = new int[data.length];
		mergeSort(data, temp, 0, data.length - 1);
	}

	private static void mergeSort(int[] data, int[] temp, int l, int r) {
		int mid = (l + r) / 2;
		if (l == r)
			return;
		mergeSort(data, temp, l, mid);
		mergeSort(data, temp, mid + 1, r);

		for (int i = l; i <= r; i++) {
			temp[i] = data[i];
		}
		int i1 = l;
		int i2 = mid + 1;
		for (int cur = l; cur <= r; cur++) {
			if (i1 == mid + 1)
				data[cur] = temp[i2++];
			else if (i2 > r)
				data[cur] = temp[i1++];
			else if (temp[i1] < temp[i2])
				data[cur] = temp[i1++];
			else

				data[cur] = temp[i2++];
		}
	}
}


--------------------------
QuickSort
--------------------------
package cn.itcast;

/*
 * 快速排序：
 * 一趟快速排序的算法是： 　　
 * 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1； 　　
 * 2）以第一个数组元素作为关键数据，赋值给key，即 key=A[0]； 　　
 * 3）从j开始向前搜索，即由后开始向前搜索（j=j-1即j--），
 * 找到第一个小于key的值A[j]，A[i]与A[j]交换； 　　
 * 4）从i开始向后搜索，即由前开始向后搜索（i=i+1即i++），
 * 找到第一个大于key的A[i]，A[i]与A[j]交换； 　　
 * 5）重复第3、4、5步，直到 I=J； 
 * (3,4步是在程序中没找到时候j=j-1，i=i+1，直至找到为止。
 * 找到并交换的时候i， j指针位置不变。
 * 另外当i=j这过程一定正好是i+或j-完成的最后令循环结束。） 
 */
public class QuickSort {
	public static void sort(int[] data) {
		quickSort(data, 0, data.length - 1);
	}

	private static void quickSort(int[] data, int i, int j) {
		int pivotIndex = (i + j) / 2;
		// swap
		SortTest.swap(data, pivotIndex, j);

		int k = partition(data, i - 1, j, data[j]);
		SortTest.swap(data, k, j);
		if ((k - i) > 1)
			quickSort(data, i, k - 1);
		if ((j - k) > 1)
			quickSort(data, k + 1, j);

	}

	/**
	 * @param data
	 * @param i
	 * @param j
	 * @return
	 */
	private static int partition(int[] data, int l, int r, int pivot) {
		do {
			while (data[++l] < pivot)
				;
			while ((r != 0) && data[--r] > pivot)
				;
			SortTest.swap(data, l, r);
		} while (l < r);
		SortTest.swap(data, l, r);
		return l;
	}
}


--------------------------
SelectionSort
--------------------------
package cn.itcast;

/*
 * 选择排序基本思路：
 * 把第一个元素依次和后面的所有元素进行比较。
 * 第一次结束后，就会有最小值出现在最前面。
 * 依次类推
 */
public class SelectionSort {
	public static void sort(int[] data) {
		for (int x = 0; x < data.length - 1; x++) {
			for (int y = x + 1; y < data.length; y++) {
				if (data[y] < data[x]) {
					SortTest.swap(data, x, y);
				}
			}
		}
	}
}


--------------------------
ShellSort
--------------------------
package cn.itcast;

/*
 * 希尔排序：先取一个小于n的整数d1作为第一个增量，
 * 把文件的全部记录分成（n除以d1）个组。所有距离为d1的倍数的记录放在同一个组中。
 * 先在各组内进行直接插入排序；然后，取第二个增量d2<d1重复上述的分组和排序，
 * 直至所取的增量dt=1(dt<dt-l<…<d2<d1)，即所有记录放在同一组中进行直接插入排序为止。 
 */
public class ShellSort {
	public static void sort(int[] data) {
		for (int i = data.length / 2; i > 2; i /= 2) {
			for (int j = 0; j < i; j++) {
				insertSort(data, j, i);
			}
		}
		insertSort(data, 0, 1);
	}

	/**
	 * @param data
	 * @param j
	 * @param i
	 */
	private static void insertSort(int[] data, int start, int inc) {
		for (int i = start + inc; i < data.length; i += inc) {
			for (int j = i; (j >= inc) && (data[j] < data[j - inc]); j -= inc) {
				SortTest.swap(data, j, j - inc);
			}
		}
	}
}
/*
 * 属于插入类排序,是将整个无序列分割成若干小的子序列分别进行插入排序 　　 
 * 排序过程：先取一个正整数d1<n，把所有序号相隔d1的数组元素放一组，
 * 组内进行直接插入排序；然后取d2<d1，重复上述分组和排序操作；直至di=1， 即所有记录放进一个组中排序为止 　　 
 * 初始：d=5 　　49 38 65 97 76 13 27 49 55 04 　　 
 * 49 13 　　|-------------------| 　　 
 * 38 27     |-------------------| 　　 
 * 65 49 　　|-------------------| 　　 
 * 97 55     |-------------------| 　　 
 * 76 04 　　|-------------------| 　　 
 * 一趟结果 　　13 27 49 55 04 49 38 65 97 76 　　 
 * d=3 　　 13 27 49  55 04 49 38 65 97 76 　　 
 * 13 55 38 76 |------------|------------|------------| 　　 
 * 27 04 65 |------------|------------| 　　 
 * 49 49 97 |------------|------------| 　　
 * 二趟结果  13 04 49* 38 27 49 55 65 97 76 　　 
 * d=1 　　13 04 49 38 27 49 55 65 97 76
 * 　　 |----|----|----|----|----|----|----|----|----| 　　 三趟结果 　　
 * 04 13 27 38 49 49 55 65 76 97
 */
 
 ---------------------------------
 SortTest
 ---------------------------------
 package cn.itcast;

import java.util.Arrays;

public class SortTest {

	public static void main(String[] args) {
		int[] arr = { 2, 5, 3, 1, 4 };
		System.out.println("排序前：" + Arrays.toString(arr));
		// InsertSort.sort(arr);
		// BubbleSort.sort(arr);
		// SelectionSort.sort(arr);
		// ShellSort.sort(arr);
		// QuickSort.sort(arr);
		// MergeSort.sort(arr);
		// HeapSort.sort(arr);
		System.out.println("排序后：" + Arrays.toString(arr));
	}

	/*
	 * 交换数组中的两个元素
	 */
	public static void swap(int[] data, int i, int j) {
		int temp = data[i];
		data[i] = data[j];
		data[j] = temp;
	}
}




1. Common Sort:
BubbleSort:
compare the neighber elements, put the bigger in the back, after the first time is done,
the max value will be put on the max index, with the same rule, we can get the array with
order.

SelectionSort:
From index 0, compare with the elements after that, put the smaller in the front,
After the first time is done, the min value will be put on the min index,
With the same rule, we can get an array with order.


2. Common Search:
Basic search: all the elements are unordered
Binary Search: all the elements are ordered
guest the middle element each time, and then compare with the half elements

3. Binary search:
define the min index and the max index
compute the mid index mid = (min + max)/2
compare the value of the mid index and target
if arr[mid] == target, return mid
if arr[mid] > target, max = mid - 1
if arr[mid] < target, min = mid + 1

---------------------------------
********************************
BinarySearch.java
********************************
package cn.itcast_04;

public class BinarySearch {
	public static int search(int[] arr, int target) {
		int begin = 0;
		int end = arr.length - 1;
	
		while (begin < end) {
			int mid = (begin + end) / 2;
			if (arr[mid] == target) {
				return mid;
			}
			else if (arr[mid] > target) {
				end = mid - 1;
			}
			else {
				begin = mid + 1;
			}
		}
		
		return -1;
	}
	
	public static int search2(int[] arr, int value) {
		int min = 0;
		int max = arr.length - 1;
		int mid = (min+max)/2;
	
		while (arr[mid] != value) {
			if (arr[mid] > value) {
				max = mid - 1;
			}
			else if (arr[mid] < value) {
				min = mid + 1;
			}
			
			if (min > max) {
				return -1;
			}
			
			mid = (min+max)/2;
		}
		
		return mid;
	}

}
**********************
SearchTest.java
**********************
package cn.itcast_04;

import cn_itcast_03.SelectionSort;

public class SearchTest {

	public static void main(String[] args) {
		int[] arr = {11, 22, 33, 44, 55, 66, 77};
		System.out.println("Before BinarySearch:");
		printArray(arr);
		int value1 = 22;
		int index = BinarySearch.search(arr, value1);
		System.out.println("The index of "+value1+" is "+index);
		System.out.println("--------------");
		
		int[] arr2 = {11, 22, 33, 44, 55, 66, 77};
		System.out.println("Before BinarySearch:");
		printArray(arr2);
		int value2 = 22;
		int index2 = BinarySearch.search2(arr2, value2);
		System.out.println("The index of "+value2+" is "+index2);
		System.out.println("-----------------");
		
		int[] arr3 = {10, 100, 89, 23, 99};
		System.out.println("Before SelectionSort:");
		printArray(arr3);
		SelectionSort.sort(arr3);
		System.out.println("After SelectionSort:");
		printArray(arr3);
		int value3 = 89;
		int index3 = BinarySearch.search2(arr3, value2);
		System.out.println("The index of "+value2+" is "+index3);
		System.out.println("-----------------");

	}
	
	public static void printArray(int[] arr) {
		System.out.print("[");
		for (int i=0; i < arr.length; ++i) {
			if (i == arr.length - 1) {
				System.out.print(arr[i]);
			}
			else {
				System.out.print(arr[i]+", ");
			}
		}
		System.out.println("]");
	}

}

********************
result:
*********************
Before BinarySearch:
[11, 22, 33, 44, 55, 66, 77]
The index of 22 is 1
--------------
Before BinarySearch:
[11, 22, 33, 44, 55, 66, 77]
The index of 22 is 1
-----------------
Before SelectionSort:
[10, 100, 89, 23, 99]
After SelectionSort:
[10, 23, 89, 99, 100]
The index of 22 is -1
-----------------
---------------------------------------------
Note:
If we want to apply binary search for unordered array, 
some people will sort it at first then use binary search
But it is unacceptable because you have changed the order of elements
after sorting
For unordered array, we only can use basic search


4. Arrays:
Class Arrays

    java.lang.Object
        java.util.Arrays 

    public class Arrays
    extends Object

    This class contains various methods for manipulating arrays 
	(such as sorting and searching). 
	This class also contains a static factory that allows arrays 
	to be viewed as lists.

    The methods in this class all throw a NullPointerException, 
	if the specified array reference is null, except where noted.

The version of Class and methods maybe not different, if the version of methods are
not written, we can think it is the same as Class

We don't need construct Arrays object, because Arrays object should not be created
We only use Arrays static method to operate many types of array

Arrays has many methods we can use, but some are used commonly
static int 	binarySearch​(int[] a, int key) 	
Searches the specified array of ints 
for the specified value using the binary search algorithm.

static void 	sort​(int[] a) 	//QuickSort
Sorts the specified array into ascending numerical order.

static String 	toString​(int[] a) 	
Returns a string representation of the contents of the specified array.

-----------------------------
package cn.itcast_01;

import java.util.Arrays;

public class ArraysTest1 {
	public static void main(String[] args) {
		int[] arr = {10, 23, 100, 230, 890};
		System.out.println("Before BinarySearch:  "+Arrays.toString(arr));
		int index = Arrays.binarySearch(arr, 23);
		System.out.println("After BinarySearch, the index of " + 23 + " is " + index);
		int[] arr2 = {100, 23, 200, 5, 90};
		System.out.println("Before sort:  "+Arrays.toString(arr2));
        Arrays.sort(arr2);
        System.out.println("After sort:  "+Arrays.toString(arr2));
		
	}

}
-----------------------------
Note:
If it is a reference object, before using it, we need judge whether it is null or not

Source code study:
    public static String toString(int[] a) {
        if (a == null)
            return "null";
        int iMax = a.length - 1;
        if (iMax == -1)
            return "[]";

        StringBuilder b = new StringBuilder();
        b.append('[');
        for (int i = 0; ; i++) {
            b.append(a[i]);
            if (i == iMax)
                return b.append(']').toString();
            b.append(", ");
        }
    }
    public static int binarySearch(int[] a, int key) {
        return binarySearch0(a, 0, a.length, key);
    }
	private static int binarySearch0(int[] a, int fromIndex, int toIndex,
                                     int key) {
        int low = fromIndex;
        int high = toIndex - 1;

        while (low <= high) {
            int mid = (low + high) >>> 1;
            int midVal = a[mid];

            if (midVal < key)
                low = mid + 1;
            else if (midVal > key)
                high = mid - 1;
            else
                return mid; // key found
        }
        return -(low + 1);  // key not found.
    }
	
	>>> k: unsigned right move k, it equals to dividing 2^k

5. Integer
Requirement 1: Compute bin, oct, hex of one dec data
Requirement 2: Judge whether a data is in the range of int
	-2^31 to 2^31 - 1(-2147483648 to 2147483647)

Class Integer

    java.lang.Object
        java.lang.Number
            java.lang.Integer 

    All Implemented Interfaces:
        Serializable, Comparable<Integer>

    public final class Integer
    extends Number
    implements Comparable<Integer>

    The Integer class wraps a value of the primitive type int in an object. 
	An object of type Integer contains a single field whose type is int.

    In addition, this class provides several methods for converting an int 
	to a String and a String to an int, as well as other constants and methods 
	useful when dealing with an int. 
	
static String 	toBinaryString​(int i) 	
Returns a string representation of the integer argument as an unsigned integer 
in base 2.
static String 	toHexString​(int i) 	
Returns a string representation of the integer argument as an unsigned integer 
in base 16.
static String 	toOctalString​(int i) 	
Returns a string representation of the integer argument as an unsigned integer 
in base 8.
String 	toString()

static int 	BYTES 	
The number of bytes used to represent an int value in two's complement binary form.
static int 	MAX_VALUE 	
A constant holding the maximum value an int can have, 231-1.
static int 	MIN_VALUE 	
A constant holding the minimum value an int can have, -231.
static int 	SIZE 	
The number of bits used to represent an int value in two's complement binary form.
static Class<Integer> 	TYPE 	
The Class instance representing the primitive type int.
 	

eclipse auto completion function:
1.Java->Editor->Content Assit（Auto Activation:Enable auto activation,Auto activation
trigger for Java(.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ)）
2.Java->Editor->Content Assit-Advanced->Java Non-type Proposals


----------------------------
***************************
source code
***************************
package cn.itcast_01;

import java.util.Arrays;

public class ArraysTest1 {
	public static void main(String[] args) {
		int[] arr = {10, 23, 100, 230, 890};
		System.out.println("Before BinarySearch:  "+Arrays.toString(arr));
		int index = Arrays.binarySearch(arr, 23);
		System.out.println("After BinarySearch, the index of " + 23 + " is " + index);
		int[] arr2 = {100, 23, 200, 5, 90};
		System.out.println("Before sort:  "+Arrays.toString(arr2));
        Arrays.sort(arr2);
        System.out.println("After sort:  "+Arrays.toString(arr2));
		
	}

}

***********************
result:
***********************
1100100
144
64
100
-2147483648
2147483647
int
4
32
-----------------------------
In order to operate basic data types, introduce class types and Wrapper Class types
basic    Reference
bytes    Byte
short    Short
int      Integer
long     Long
float    Float
double   Double
char     Character
boolean  Boolean

They can be used to convert between basic types and String types

----------------------------
Constructors Constructor 	Description
Integer​(int value) 	
Deprecated.
It is rarely appropriate to use this constructor.
Integer​(String s) 	
Deprecated.
It is rarely appropriate to use this constructor.

--------------------------------
**********
source code
**********************
package cn.itcast_01;

public class IntegerTest2 {

	public static void main(String[] args) {
//		method 1
		int i = 100;
		Integer ii = new Integer(i);
		System.out.println(ii); // 100, rewrite toString()
		
//      method 2
		String str = "100";
		Integer iii = new Integer(str);
		System.out.println(iii);// 100
		
//		exception
//		String str2 = "abc";
//		Integer ii2 = new Integer(str2);// java.lang.NumberFormatException
//		System.out.println(ii2);

		
	}

}

************
result:
100
100
*************
Note: String must be consisted of integers instead of chars
-------------------------------
String<->int
int 	intValue() 	
Returns the value of this Integer as an int.

static int 	parseInt​(String s) 	
Parses the string argument as a signed decimal integer.

static int 	parseInt​(String s, int radix) 	
Parses the string argument as a signed integer in the radix 
specified by the second argument.

String 	toString() 	
Returns a String object representing this Integer's value.
static String 	toString​(int i) 	
Returns a String object representing the specified integer.

static String 	toString​(int i, int radix) 	
Returns a string representation of the first argument in the 
radix specified by the second argument.

static Integer 	valueOf​(int i) 	
Returns an Integer instance representing the specified int value.
static Integer 	valueOf​(String s) 	
Returns an Integer object holding the value of the specified String.
static Integer 	valueOf​(String s, int radix) 	
Returns an Integer object holding the value extracted from the specified
 String when parsed with the radix given by the second argument.
 
---------------------------
****************************
package cn.itcast_01;

public class IntStringConversionTest {

	public static void main(String[] args) {
//		int to String
//		String.valueOf(int)
		
//		method 1: String joint
		int num = 100;
		String str = "" + num;
		System.out.println(str);

//		method 2: Integer.toString
		String str2 = Integer.toString(num);
		System.out.println(str2);
		
//		method 3: String.valueOf, recommended
		String str3 = String.valueOf(num);
		System.out.println(str3);
		
//		method 4: Integer.toString()
		Integer integer = new Integer(num);
		String str4 = integer.toString();
		System.out.println(str4);
		
		
		
//		String to int
//		integer.parseInt(s);
		
//		method 1:
		String str5 = "100";
	    Integer i5 = new Integer(str5);
	    int x5 = i5.intValue();
	    System.out.println(x5);

//	    method 2:
//	    String str6 = "200";
//	    Integer i6 = Integer.getInteger(str6);
//	    int x6 = i6.intValue();//NullPointerException
//	    System.out.println(x6);
	    
//	    method 2:
	    String str6 = "200";
	    int x6 = Integer.parseInt(str6);
	    System.out.println(x6);
	    
	}

}

**************
result:
100
100
100
100
100
200
****************
---------------------------------------

SysConvert:
Dec->Bin, Oct, Hex
static String 	toBinaryString​(int i) 	
Returns a string representation of the integer argument 
as an unsigned integer in base 2.
static String 	toHexString​(int i) 	
Returns a string representation of the integer argument 
as an unsigned integer in base 16.
static String 	toOctalString​(int i) 	
Returns a string representation of the integer argument 
as an unsigned integer in base 8.

Dec->Other sys (2 to 36)(0-9,a-z: 36 in total)
static String 	toString​(int i, int radix) 	
Returns a string representation of the first argument in the radix
 specified by the second argument.

Other sys->Dec:
static int 	parseInt​(String s, int radix) 	
Parses the string argument as a signed integer 
in the radix specified by the second argument.

*************************
package cn.itcast_01;

public class DecToOtherSysTest {

	public static void main(String[] args) {
//		Dec->Bin, Oct, Hex
		int num = 100;
		System.out.println(Integer.toBinaryString(num));
		System.out.println(Integer.toOctalString(num));
		System.out.println(Integer.toHexString(num));
		System.out.println("----------------");
		
//		Dec->other sys(2 to 36)
		System.out.println(Integer.toString(num, 10));
		System.out.println(Integer.toString(num, 2));
		System.out.println(Integer.toString(num, 8));
		System.out.println(Integer.toString(num, 16));
		System.out.println(Integer.toString(num, 17));
		System.out.println(Integer.toString(num, 32));
		System.out.println(Integer.toString(num, 36));
		System.out.println(Integer.toString(num, 37));
		System.out.println(Integer.toString(num, 5));
		System.out.println(Integer.toString(num, 7));
		System.out.println(Integer.toString(num, 20));
	
		System.out.println(Integer.toString(num, 100));
		System.out.println(Integer.toString(num, -5));
		System.out.println(Integer.toString(num, -7));
		System.out.println("-----------------");
		
//		Other sys->Dec
		System.out.println(Integer.parseInt("100", 10));
		System.out.println(Integer.parseInt("100", 2));
		System.out.println(Integer.parseInt("100", 8));
		System.out.println(Integer.parseInt("100", 16));
		System.out.println(Integer.parseInt("100", 5));
//		System.out.println(Integer.parseInt("123", 2));//java.lang.NumberFormatException
	}
}


**************************
result:
1100100
144
64
----------------
100
1100100
144
64
5f
34
2s
100
400
202
50
100
100
100
-----------------
100
4
64
256
25
***********************
----------------------------



JDK5 new feature:
Auto wrapper: basic type into wrapper type
Auto unwrapper: wrapper type into basic type

Note: NullPointerException, before using Integer method, we need judge if Integer
is null, if it is not null, we can call Integer methods
if (i != null) {
	int x = i.intValue();
}

***********************
Integer ii = 100;
ii += 200;
System.out.println("ii:"+ii);

After decompiling:
Integer ii = Integer.valueOf(100);
ii = Integer.valueOf(ii.intValue() + 200);
System.out.println(new StringBuilder("ii:").append(ii).toString());
***********************
package cn.itcast_01;

public class AutoWrapperTest {

	public static void main(String[] args) {
		Integer i1 = new Integer(100);
//		Integer i2 = 200;// JDK5 is OK
//		i2 += 100;
		System.out.println(i1.intValue());


	}

}
Note: It will report compilation error in JDK12
---------------------------------

Q1: Integer i1 = 127;  
// -128 to 127(Byte type of data)
// if the data is in the range of it, we don't need create new memory
    public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }


    valueOf

    public static Integer valueOf​(int i)

    Returns an Integer instance representing the specified int value. If a new Integer instance is not required, this method should generally be used in preference to the constructor Integer(int), as this method is likely to yield significantly better space and time performance by caching frequently requested values. This method will always cache values in the range -128 to 127, inclusive, and may cache other values outside of this range.

    Parameters:
        i - an int value.
    Returns:
        an Integer instance representing i.
    Since:
        1.5

**********************
package cn.itcast_01;

public class IntegerTest3 {

	public static void main(String[] args) {
		Integer i1 = new Integer(127);
		Integer i2 = new Integer(127);
		System.out.println(i1 == i2);       // false
		System.out.println(i1.equals(i2));  // true
		System.out.println("-----------------");
		
		Integer i3 = new Integer(128);
		Integer i4 = new Integer(128);
		System.out.println(i3 == i4);      // false
		System.out.println(i3.equals(i4)); // true
		System.out.println("-----------------");
		
		Integer i5 = Integer.valueOf(127); // Integer i5 = 127;
		Integer i6 = Integer.valueOf(127); // Integer i6 = 127;
		System.out.println(i5 == i6);      // true
		System.out.println(i5.equals(i6)); // true
		System.out.println("-----------------");
		
		Integer i7 = Integer.valueOf(128); // Integer i7 = 128;
		Integer i8 = Integer.valueOf(128); // Integer i8 = 128;
		System.out.println(i7 == i8);      // false, new memory out the range of -128 to 127
		System.out.println(i7.equals(i8)); // true
		System.out.println("-----------------");
	}

}
*************************

Character:
Class Character

    java.lang.Object
        java.lang.Character 

    All Implemented Interfaces:
        Serializable, Comparable<Character>

    public final class Character
    extends Object
    implements Serializable, Comparable<Character>

    The Character class wraps a value of the primitive type char in an object. 
	An object of type Character contains a single field whose type is char.

    In addition, this class provides several methods for determining a character's
	category (lowercase letter, digit, etc.) and for converting characters from 
	uppercase to lowercase and vice versa.

    Character information is based on the Unicode Standard, version 8.0.0.

    The methods and data of class Character are defined by the information in 
	the UnicodeData file that is part of the Unicode Character Database 
	maintained by the Unicode Consortium. This file specifies various properties 
	including name and general category for every defined Unicode code point or 
	character range. 
	
----------------------
Constructors Constructor 	Description
Character​(char value) 	
Deprecated.
It is rarely appropriate to use this constructor.

common methods:
static boolean 	isDigit​(char ch) 	
Determines if the specified character is a digit.

static boolean 	isLowerCase​(char ch) 	
Determines if the specified character is a lowercase character.

static boolean 	isUpperCase​(char ch) 	
Determines if the specified character is an uppercase character.

static char 	toLowerCase​(char ch) 	
Converts the character argument to lowercase 
using case mapping information from the UnicodeData file.

static char 	toUpperCase​(char ch) 	
Converts the character argument to uppercase using case 
mapping information from the UnicodeData file.

******************
package day13_Character;

public class CharacterTest1 {

	public static void main(String[] args) {
//		Character character = new Character(97); // compile error
//		Character ch = new Character((char) 97);
		Character ch = new Character('a');
		System.out.println("ch:"+ch);// Character rewrite toString()
		System.out.println("----------");
		
		System.out.println(Character.isDigit('a'));
		System.out.println(Character.isLowerCase('a'));
		System.out.println(Character.isUpperCase('a'));
		System.out.println(Character.toLowerCase('a'));
		System.out.println(Character.toUpperCase('a'));
		System.out.println("---------");
		
		System.out.println(Character.isDigit('1'));
		System.out.println(Character.isLowerCase('A'));
		System.out.println(Character.isUpperCase('A'));
		System.out.println(Character.toLowerCase('A'));
		System.out.println(Character.toUpperCase('A'));
		

	}

}

result:
ch:a
----------
false
true
false
a
A
---------
true
false
true
a
A
***************
Compute the number of digits, lowerCases and upperCases
****************
package day13_Character;

import java.util.Scanner;

public class ComputeCountTest {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("Please enter a String:");
		String str = sc.nextLine();
		compute(str);

	}
	
	public static void compute(String str) {
		int digitsCount       = 0;
		int lowerCasesCount   = 0;
		int upperCasesCount   = 0;
		
		char[] chs = str.toCharArray();
		for (int i = 0; i < chs.length; ++i) {
			if (Character.isDigit(chs[i])) {
				digitsCount++;
			}
			else if (Character.isLowerCase(chs[i])) {
				lowerCasesCount++;
			}
			else if (Character.isUpperCase(chs[i])) {
				upperCasesCount++;
			}
		}
		
		System.out.println("The number of digits is " + digitsCount);
		System.out.println("The number of lowerCases is " + lowerCasesCount);
		System.out.println("The number of upperCases is " + upperCasesCount);
	}

}

result:
Please enter a String:
abcABC123455aaaabbbGSG,.
The number of digits is 6
The number of lowerCases is 10
The number of upperCases is 6
*********************************************

	
