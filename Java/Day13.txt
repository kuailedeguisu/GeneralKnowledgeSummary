1.StringBuffer
public final class StringBuffer
extends Object
implements Serializable, Comparable<StringBuffer>, CharSequence
A thread-safe, mutable sequence of characters. A string buffer is like a String, but can be modified. 
At any point in time it contains some particular sequence of characters, but the length and content of the sequence 
can be changed through certain method calls.
String buffers are safe for use by multiple threads. The methods are synchronized where necessary 
so that all the operations on any particular instance behave as if they occur in some serial order 
that is consistent with the order of the method calls made by each of the individual threads involved.

The principal operations on a StringBuffer are the append and insert methods, which are overloaded 
so as to accept data of any type. Each effectively converts a given datum to a string and then 
appends or inserts the characters of that string to the string buffer. The append method always 
adds these characters at the end of the buffer; the insert method adds the characters at a specified point.
-----------------------------------------------------------
thread-safe: sync(data can't be operated at the same time, safe)
thread-unsafe:not sync(efficiently)
You only have safety or efficience.We only can consider one item according to the situation.
bank:               safe
news and internet:  efficience
---------------------------------------------------------
StringBuffer: thread-safe, mutable sequene
The difference between StringBuffer and String:
StringBuffer: length and content of it are changed, String appending will not waste a lot of memory
String: length and content of it are not changed, String appending will waste a lot of memory
----------------------
StringBuffer constructor methods:
StringBuffer()	
Constructs a string buffer with no characters in it and an initial capacity of 16 characters.
StringBuffer​(int capacity)	
Constructs a string buffer with no characters in it and the specified initial capacity.
StringBuffer​(CharSequence seq)	
Constructs a string buffer that contains the same characters as the specified CharSequence.
StringBuffer​(String str)	
Constructs a string buffer initialized to the contents of the specified string.
--------------------
CharSequence
Interface CharSequence
All Known Subinterfaces:
Name
All Known Implementing Classes:
CharBuffer, Segment, String, StringBuffer, StringBuilder
-------------------
public StringBuffer(String str) {
        super(str.length() + 16);
        append(str);
    }
    --------------
StringBuffer member methods:
capacity: theorical value
public int capacity()
Returns the current capacity. The capacity is the amount of storage available for newly inserted characters, beyond which an allocation will occur.
Returns:
the current capacity

length: actural value
int length()
Returns the length of this character sequence. The length is the number of 16-bit chars in the sequence.
Returns:
the number of chars in this sequence


1. StringBuffer add function:
1) append
// We can append any data types of data into StringBuffer
// and return the StringBuffer itself

java.lang.AbstractStringBuilder 	append​(boolean b) 	
Appends the string representation of the boolean argument to the sequence.

java.lang.AbstractStringBuilder 	append​(char c) 	
Appends the string representation of the char argument to this sequence.

java.lang.AbstractStringBuilder 	append​(char[] str) 	
Appends the string representation of the char array argument to this sequence.

java.lang.AbstractStringBuilder 	append​(double d) 	
Appends the string representation of the double argument to this sequence.

java.lang.AbstractStringBuilder 	append​(float f) 	
Appends the string representation of the float argument to this sequence.

java.lang.AbstractStringBuilder 	append​(int i) 	
Appends the string representation of the int argument to this sequence.

java.lang.AbstractStringBuilder 	append​(long l) 	
Appends the string representation of the long argument to this sequence.

java.lang.AbstractStringBuilder 	append​(Object obj) 	
Appends the string representation of the Object argument.

java.lang.AbstractStringBuilder 	append​(String str) 	
Appends the specified string to this character sequence.

StringBuffer 	append​(char[] str, int offset, int len) 	
Appends the string representation of a subarray of the char array argument to this sequence.

StringBuffer 	append​(CharSequence s) 	
Appends the specified CharSequence to this sequence.

StringBuffer 	append​(CharSequence s, int start, int end) 	
Appends a subsequence of the specified CharSequence to this sequence.

StringBuffer 	append​(StringBuffer sb) 	
Appends the specified StringBuffer to this sequence.

StringBuffer 	appendCodePoint​(int codePoint) 	
Appends the string representation of the codePoint argument to this sequence.
/////////////////////////////
package cn.itcast_01;

public class StringBufferAddTest1 {

	public static void main(String[] args) {
		StringBuffer sb = new StringBuffer();
//		Method1: Check addresses
//		StringBuffer sb2 = sb.append("hello");
//		System.out.println(sb);// "hello"
//		System.out.println(sb2);// "hello"
//		System.out.println(sb == sb2);// true
		
//		Method2: append step to step
//		sb.append("hello");
//		sb.append(10);
//		sb.append(true);
//		sb.append(10.9);
//		System.out.println(sb);

//		Method3: link coding
		sb.append("hello").append(10).append(true).append(123.456);
		System.out.println(sb);
		
	}
}
////////////////////////////////////////



2) insert
// Insert any data genre of data in the specified index
// The original elements will be moved to after the inserted string

StringBuffer 	insert​(int offset, boolean b) 	
Inserts the string representation of the boolean argument into this sequence.

StringBuffer 	insert​(int offset, char c) 	
Inserts the string representation of the char argument into this sequence.

StringBuffer 	insert​(int offset, char[] str) 	
Inserts the string representation of the char array argument into this sequence.

StringBuffer 	insert​(int index, char[] str, int offset, int len) 	
Inserts the string representation of a subarray of the str array argument into this sequence.

StringBuffer 	insert​(int offset, double d) 	
Inserts the string representation of the double argument into this sequence.

StringBuffer 	insert​(int offset, float f) 	
Inserts the string representation of the float argument into this sequence.

StringBuffer 	insert​(int offset, int i) 	
Inserts the string representation of the second int argument into this sequence.

StringBuffer 	insert​(int offset, long l) 	
Inserts the string representation of the long argument into this sequence.

StringBuffer 	insert​(int dstOffset, CharSequence s) 	
Inserts the specified CharSequence into this sequence.

StringBuffer 	insert​(int dstOffset, CharSequence s, int start, int end) 	
Inserts a subsequence of the specified CharSequence into this sequence.

StringBuffer 	insert​(int offset, Object obj) 	
Inserts the string representation of the Object argument into this character sequence.

StringBuffer 	insert​(int offset, String str) 	
Inserts the string into this character sequence.

////////////////////////
package cn.itcast_01;

public class StringBufferInsertTest {

	public static void main(String[] args) {
		StringBuffer sb = new StringBuffer();
		sb.append("hello").append("world").append(true).append(123.456);
		sb.insert(5, "big").insert(13, "itis");
		System.out.println(sb);

	}

}
/////////////////////////
2. StringBuffer delete function
StringBuffer 	delete​(int start, int end) 	
Removes the characters in a substring of this sequence.

StringBuffer 	deleteCharAt​(int index) 	
Removes the char at the specified position in this sequence.

///////////////////
package cn.itcast_01;

public class StringBufferDeleteTest {

	public static void main(String[] args) {
		StringBuffer sb = new StringBuffer();
		sb.append("hello").append("world").append(true).append(123.456);
		System.out.println(sb); // "helloworldtrue123.456"
		sb.deleteCharAt(0);
		System.out.println(sb); // "elloworldtrue123.456"
		sb.delete(0, 4);
		System.out.println(sb); // "worldtrue123.456"
		sb.delete(0, sb.length());
		System.out.println(sb); // ""
	}

}
//////////////////////////////////

3. StringBuffer replace function
StringBuffer 	replace​(int start, int end, String str) 	
Replaces the characters in a substring of this sequence with characters in the specified String.
-------------------------
package cn.itcast_01;

public class StringBufferReplaceTest {

	public static void main(String[] args) {
		StringBuffer sb = new StringBuffer();
		sb.append("helloworld").append(true).append(100).append(123.456);
		System.out.println(sb);
		sb.replace(10, 14, "false");
		System.out.println(sb);
		sb.replace(10, 15, "true");
		System.out.println(sb);

	}

}
-----------------------------
4. StringBuffer reverse function
StringBuffer 	reverse() 	
Causes this character sequence to be replaced by the reverse of the sequence.
--------------------------------
package cn.itcast_01;

public class StringBufferReverseTest {

	public static void main(String[] args) {
		StringBuffer sb = new StringBuffer();
		sb.append("helloworld").append(true).append(1998);
		System.out.println(sb);
		sb.reverse();
		System.out.println(sb);
	}

}
--------------------------------------

5. StringBuffer substring function
// Return String instead of StringBuffer
// It won't return StringBuffer itself

String 	substring​(int start) 	
Returns a new String that contains a subsequence of characters currently 
contained in this character sequence.

String 	substring​(int start, int end) 	
Returns a new String that contains a subsequence of characters currently 
contained in this sequence.

---------------------------
package cn.itcast_01;

public class StringBufferSubstringTest {

	public static void main(String[] args) {
		StringBuffer sb = new StringBuffer();
		sb.append("helloworld").append("hellosky").append(true);
		System.out.println(sb);
		StringBuffer sb2 = new StringBuffer(sb.substring(10));
		System.out.println(sb);
		System.out.println(sb2);

	}

}
----------------------------------
6. StringBuffer and String convert
class A->class B: use class B methods
class B->class A: because we need return class A 
String can't be assiged to StringBuffer
Any reference type of data can be converted into String by means of toString()

--------------------------
package cn.itcast_01;

public class StringBufferStringConvertTest {

	public static void main(String[] args) {
//		String->StringBuffer
//		method1: StringBuffer constructor method
		String str = "hello";
		StringBuffer sb = new StringBuffer(str);
		System.out.println(sb);

//		method2: StringBuffer append method
		StringBuffer sb1 = new StringBuffer();
		sb1.append(str);
		System.out.println(sb1);
		
//		StringBuffer->String
//		method1: String constructor
		StringBuffer sb2 = new StringBuffer("HelloSkyHelloWorld");
		String str2 = new String(sb2);
		System.out.println(sb2);
		System.out.println(str2);
		
//		method2 ： substring
		StringBuffer sb3 = new StringBuffer("helloworldhelosky");
		String str3 = sb3.substring(0);
		System.out.println(sb3);
		System.out.println(str3);
		
//		method3: toString
		StringBuffer sb4 = new StringBuffer("StudyHard");
		String str4 = sb4.toString();
		System.out.println(sb4);
		System.out.println(str4);
	}

}
------------------------------------------


7. Joint an array into a String
Recommend method 2: use the same memory
---------------------------------
package cn.itcast_01;

public class ArrayJointToStringTest {

	public static void main(String[] args) {
		int arr[] = {1, 2, 3, 4, 5, 6};
		System.out.println(arrayToString(arr));
		System.out.println(arrayToString2(arr));

	}
	
//	method 1: String
	public static String arrayToString(int[] arr) {
		int len = arr.length;
		
		String result = "";
		
		result += "[";
		
		for (int i = 0; i < len; ++i) {
			if (i == len -1) {
				result += arr[i];
				result += "]";
			} else {
				result += arr[i];
				result += ", ";
			}
		}
		
		return result;
	}
	
// method 2: StringBuffer
	public static String arrayToString2(int[] arr) {
		int len = arr.length;
		
		StringBuffer sb = new StringBuffer();
		String result;
		
		sb.append("[");
		
		for (int i = 0; i < len; ++i) {
			if (i == len -1) {
				sb.append(arr[i]).append("]");
			} else {
				sb.append(arr[i]).append(", ");
			}
		}
		
		result = new String(sb);
		
		return result;
	}

}

result:
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
---------------------------------------------

8. reverse String
-------------------------------------------
package cn.itcast_01;

public class StringReverseTest {

	public static void main(String[] args) {
		String str = "HelloWorld!";
		System.out.println(reverseString1(str));
		System.out.println(reverseString2(str));
		System.out.println(reverseString3(str));
	}
	
//	method 1 : length() and charAt()
	public static String reverseString1(String str) {
		int len = str.length();
		String result = "";
		
		for (int i=0; i < len; ++i) {
			result += str.charAt(len - 1 - i);
		}
		
		return result;
		
	}
	
//	method 2 : toCharArray()
	public static String reverseString2(String str) {
		char[] chs = str.toCharArray();
		String result = "";
		
		for (int i=0; i < chs.length; ++i) {
			result += chs[chs.length - 1 - i];
		}
		
		return result;
		
	}
	
	
//	method 3: StringBuffer()
	public static String reverseString3(String str) {
		return new StringBuffer(str).reverse().toString();
		
	}

}

result:
!dlroWolleH
!dlroWolleH
!dlroWolleH
-----------------------

9. Judge whether one String is symmetric
----------------------------------------------
package cn.itcast_01;

import java.util.Scanner;

public class StringSymmetryTest {

	public static void main(String[] args) {	
		Scanner sc = new Scanner(System.in);
		System.out.println("Please enter a string");
		String enteredStr = sc.nextLine();
		System.out.println(isStringSymmetry1(enteredStr));
		System.out.println(isStringSymmetry2(enteredStr));
		System.out.println(isStringSymmetry3(enteredStr));
		System.out.println(isStringSymmetry4(enteredStr));

	}
	
//	method 1: length() and charAt()
	public static boolean isStringSymmetry1(String str) {
		int len = str.length();
		
		for (int i=0; i < len/2; ++i ) {
			if (str.charAt(i) != str.charAt(len - 1 - i)) {
				return false;
			}
		}
		
		return true;
	}


//	method 2: StringBuffer reverse()
	public static boolean isStringSymmetry2(String str) {
		return new StringBuffer(str).reverse().toString().equals(str);
	}
	
//	method 3:toCharArray()
	public static boolean isStringSymmetry3(String str) {
		boolean flag = true;
		char[] chs = str.toCharArray();
		
		for (int i=0; i < chs.length; ++i ) {
			if (chs[i] != chs[chs.length - 1 - i]) {
				flag = false;
				break;
			}
		}
		
		return flag;
	}
	
//	method 4:toCharArray(), start, end
	public static boolean isStringSymmetry4(String str) {
		char[] chs = str.toCharArray();
		
		for (int start = 0, end = chs.length - 1; start <= end; start++, end--) {
			if (chs[start] != chs[end]) {
				return false;
			}
		}
		
		return true;
	}
}
------------------------------------------------------------

10. The differences among String, StringBuffer, StringBuilder
A: String's contents are not changed, while StringBuffer's and StringBuilder's
contents are changed
B: StringBuffer is thread-safe(synced), data is safe but not efficient.
StringBuilder is not thread-safe(not synced), data is not safe but efficent


Class StringBuilder

    java.lang.Object
        java.lang.StringBuilder 

    All Implemented Interfaces:
        Serializable, Appendable, CharSequence

    public final class StringBuilder
    extends Object
    implements Serializable, CharSequence

    A mutable sequence of characters. This class provides an API compatible with 
	StringBuffer, but with no guarantee of synchronization. 
	This class is designed for use as a drop-in replacement 
	for StringBuffer in places where the string buffer was 
	being used by a single thread (as is generally the case). 
	Where possible, it is recommended that this class be used in 
	preference to StringBuffer as it will be faster under most implementations.

    The principal operations on a StringBuilder are the append and insert methods, 
	which are overloaded so as to accept data of any type. Each effectively 
	converts a given datum to a string and then appends or inserts the characters 
	of that string to the string builder. The append method always adds these 
	characters at the end of the builder; the insert method adds the characters 
	at a specified point.

    For example, if z refers to a string builder object whose current contents are "start",
	then the method call z.append("le") would cause the string builder to contain "startle",
	whereas z.insert(4, "le") would alter the string builder to contain "starlet".

    In general, if sb refers to an instance of a StringBuilder, then sb.append(x) has the 
	same effect as sb.insert(sb.length(), x).

    Every string builder has a capacity. As long as the length of the character sequence 
	contained in the string builder does not exceed the capacity, it is not necessary to 
	allocate a new internal buffer. If the internal buffer overflows, it is automatically 
	made larger.

    Instances of StringBuilder are not safe for use by multiple threads. 
	If such synchronization is required then it is recommended that StringBuffer be used.

    Unless otherwise noted, passing a null argument to a constructor or method 
	in this class will cause a NullPointerException to be thrown.
	
11. The differences between StringBuffer and Array
A: Both of them are containers, store other data.
B: StringBuffer only can contain String data;
Array can contain any type of data, but all data elements in one Array must be the same.

12. String and StringBuffer as the formal parameter of one method
formal parameter:
basic type: the change of formal parameters won't change actural parameters
reference type: the change of formal parameters will change actural parameters

We can use debug pattern to see what's happened.
F6: move to next step
F5: step into the called method, then use F6 to move to the next step in the called method

String as formal parameter of one method, it is the same as basic type
StringBuffer as formal parameter of one method, we only can change actural parameter when calling 
StringBuffer method, such as append(), insert(), etc.


13. Array sort and find
Array sort: we can see the video for each Array sort
--------------------------
BubbleSort
--------------------------
package cn.itcast;

/*
 * 冒泡排序基本概念是：
 * 依次比较相邻的两个数，将小数放在前面，大数放在后面。
 * 即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。
 * 然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，
 * 直至比较最后两个数，将小数放前，大数放后。至此第一趟结束，
 * 将最大的数放到了最后。在第二趟：仍从第一对数开始比较
 * （因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数），
 * 将小数放前，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是最大的），
 * 第二趟结束，在倒数第二的位置上得到一个新的最大数
 * （其实在整个数列中是第二大的数）。如此下去，重复以上过程，直至最终完成排序。 
 */
public class BubbleSort {
	public static void sort(int[] data) {
		for (int i = 0; i < data.length - 1; i++) {
			for (int j = 0; j < data.length - 1 - i; j++) {
				if (data[j] > data[j + 1]) {
					SortTest.swap(data, j, j + 1);
				}
			}
		}
	}
}

--------------------------
HeapSort
--------------------------
package cn.itcast;

public class HeapSort {
	public static void sort(int[] data) {
		MaxHeap h = new MaxHeap();
		h.init(data);
		for (int i = 0; i < data.length; i++)
			h.remove();
		System.arraycopy(h.queue, 1, data, 0, data.length);
	}

	private static class MaxHeap {

		void init(int[] data) {
			this.queue = new int[data.length + 1];
			for (int i = 0; i < data.length; i++) {
				queue[++size] = data[i];
				fixUp(size);
			}
		}

		private int size = 0;

		private int[] queue;

		public int get() {
			return queue[1];

		}

		public void remove() {
			SortTest.swap(queue, 1, size--);
			fixDown(1);
		}

		// fixdown
		private void fixDown(int k) {
			int j;
			while ((j = k << 1) <= size) {
				if (j < size && queue[j] < queue[j + 1])
					j++;
				if (queue[k] > queue[j]) // 不用交换

					break;
				SortTest.swap(queue, j, k);
				k = j;
			}
		}

		private void fixUp(int k) {
			while (k > 1) {
				int j = k >> 1;
				if (queue[j] > queue[k])
					break;
				SortTest.swap(queue, j, k);

				k = j;
			}
		}

	}
}
/*
 * 堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征， 使得在当前无序区中选取最大（或最小）关键字的记录变得简单。 　　
 * （1）用大根堆排序的基本思想 　　 ① 先将初始文件R[1..n]建成一个大根堆，此堆为初始的无序区 　　 ②
 * 再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个 记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，
 * 且满足R[1..n-1].keys≤R[n].key 　　 ③由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。
 * 然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，
 * 由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，
 * 且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。 　 直到无序区只有一个元素为止。 　　
 * （2）大根堆排序算法的基本操作： 　　 ① 初始化操作：将R[1..n]构造为初始堆； 　　 ②
 * 每一趟排序的基本操作：将当前无序区的堆顶记录R[1]和该区间的最后一个记录交换， 然后将新的无序区调整为堆（亦称重建堆）。
 */
 
 
--------------------------
InsertSort
--------------------------
 package cn.itcast;

/*
 * 插入排序基本思想
 * 将n个元素的数列分为已有序和无序两个部分，如插入排序过程示例下所示： 　　
 * {{a1}，{a2，a3，a4，…，an}} 　　
 * {{a1⑴，a2⑴}，{a3⑴，a4⑴ …，an⑴}} 　
 * {{a1(n-1），a2(n-1) ，…},{an(n-1)}} 　　
 * 每次处理就是将无序数列的第一个元素与有序数列的元素从后往前逐个进行比较，
 * 找出插入位置，将该元素插入到有序数列的合适位置中。
 */
public class InsertSort {
	public static void sort(int[] data) {
		for (int i = 1; i < data.length; i++) {
			for (int j = i; (j > 0) && (data[j] < data[j - 1]); j--) {
				SortTest.swap(data, j, j - 1);
			}
		}

	}
}


--------------------------
MergeSort
--------------------------
package cn.itcast;

/*
 * 归并操作(merge)，也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。 　　
 * 如设有数列{6，202，100，301，38，8，1} 　　
 * 初始状态： [6] [202] [100] [301] [38] [8] [1] 比较次数 　　
 * i=1 [6 202 ] [ 100 301] [ 8 38] [ 1 ]　3 　　
 * i=2 [ 6 100 202 301 ] [ 1 8 38 ]　4 　　
 * i=3　[ 1 6 8 38 100 202 301 ] 4 
 */
public class MergeSort {
	public static void sort(int[] data) {
		int[] temp = new int[data.length];
		mergeSort(data, temp, 0, data.length - 1);
	}

	private static void mergeSort(int[] data, int[] temp, int l, int r) {
		int mid = (l + r) / 2;
		if (l == r)
			return;
		mergeSort(data, temp, l, mid);
		mergeSort(data, temp, mid + 1, r);

		for (int i = l; i <= r; i++) {
			temp[i] = data[i];
		}
		int i1 = l;
		int i2 = mid + 1;
		for (int cur = l; cur <= r; cur++) {
			if (i1 == mid + 1)
				data[cur] = temp[i2++];
			else if (i2 > r)
				data[cur] = temp[i1++];
			else if (temp[i1] < temp[i2])
				data[cur] = temp[i1++];
			else

				data[cur] = temp[i2++];
		}
	}
}


--------------------------
QuickSort
--------------------------
package cn.itcast;

/*
 * 快速排序：
 * 一趟快速排序的算法是： 　　
 * 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1； 　　
 * 2）以第一个数组元素作为关键数据，赋值给key，即 key=A[0]； 　　
 * 3）从j开始向前搜索，即由后开始向前搜索（j=j-1即j--），
 * 找到第一个小于key的值A[j]，A[i]与A[j]交换； 　　
 * 4）从i开始向后搜索，即由前开始向后搜索（i=i+1即i++），
 * 找到第一个大于key的A[i]，A[i]与A[j]交换； 　　
 * 5）重复第3、4、5步，直到 I=J； 
 * (3,4步是在程序中没找到时候j=j-1，i=i+1，直至找到为止。
 * 找到并交换的时候i， j指针位置不变。
 * 另外当i=j这过程一定正好是i+或j-完成的最后令循环结束。） 
 */
public class QuickSort {
	public static void sort(int[] data) {
		quickSort(data, 0, data.length - 1);
	}

	private static void quickSort(int[] data, int i, int j) {
		int pivotIndex = (i + j) / 2;
		// swap
		SortTest.swap(data, pivotIndex, j);

		int k = partition(data, i - 1, j, data[j]);
		SortTest.swap(data, k, j);
		if ((k - i) > 1)
			quickSort(data, i, k - 1);
		if ((j - k) > 1)
			quickSort(data, k + 1, j);

	}

	/**
	 * @param data
	 * @param i
	 * @param j
	 * @return
	 */
	private static int partition(int[] data, int l, int r, int pivot) {
		do {
			while (data[++l] < pivot)
				;
			while ((r != 0) && data[--r] > pivot)
				;
			SortTest.swap(data, l, r);
		} while (l < r);
		SortTest.swap(data, l, r);
		return l;
	}
}


--------------------------
SelectionSort
--------------------------
package cn.itcast;

/*
 * 选择排序基本思路：
 * 把第一个元素依次和后面的所有元素进行比较。
 * 第一次结束后，就会有最小值出现在最前面。
 * 依次类推
 */
public class SelectionSort {
	public static void sort(int[] data) {
		for (int x = 0; x < data.length - 1; x++) {
			for (int y = x + 1; y < data.length; y++) {
				if (data[y] < data[x]) {
					SortTest.swap(data, x, y);
				}
			}
		}
	}
}


--------------------------
ShellSort
--------------------------
package cn.itcast;

/*
 * 希尔排序：先取一个小于n的整数d1作为第一个增量，
 * 把文件的全部记录分成（n除以d1）个组。所有距离为d1的倍数的记录放在同一个组中。
 * 先在各组内进行直接插入排序；然后，取第二个增量d2<d1重复上述的分组和排序，
 * 直至所取的增量dt=1(dt<dt-l<…<d2<d1)，即所有记录放在同一组中进行直接插入排序为止。 
 */
public class ShellSort {
	public static void sort(int[] data) {
		for (int i = data.length / 2; i > 2; i /= 2) {
			for (int j = 0; j < i; j++) {
				insertSort(data, j, i);
			}
		}
		insertSort(data, 0, 1);
	}

	/**
	 * @param data
	 * @param j
	 * @param i
	 */
	private static void insertSort(int[] data, int start, int inc) {
		for (int i = start + inc; i < data.length; i += inc) {
			for (int j = i; (j >= inc) && (data[j] < data[j - inc]); j -= inc) {
				SortTest.swap(data, j, j - inc);
			}
		}
	}
}
/*
 * 属于插入类排序,是将整个无序列分割成若干小的子序列分别进行插入排序 　　 
 * 排序过程：先取一个正整数d1<n，把所有序号相隔d1的数组元素放一组，
 * 组内进行直接插入排序；然后取d2<d1，重复上述分组和排序操作；直至di=1， 即所有记录放进一个组中排序为止 　　 
 * 初始：d=5 　　49 38 65 97 76 13 27 49 55 04 　　 
 * 49 13 　　|-------------------| 　　 
 * 38 27     |-------------------| 　　 
 * 65 49 　　|-------------------| 　　 
 * 97 55     |-------------------| 　　 
 * 76 04 　　|-------------------| 　　 
 * 一趟结果 　　13 27 49 55 04 49 38 65 97 76 　　 
 * d=3 　　 13 27 49  55 04 49 38 65 97 76 　　 
 * 13 55 38 76 |------------|------------|------------| 　　 
 * 27 04 65 |------------|------------| 　　 
 * 49 49 97 |------------|------------| 　　
 * 二趟结果  13 04 49* 38 27 49 55 65 97 76 　　 
 * d=1 　　13 04 49 38 27 49 55 65 97 76
 * 　　 |----|----|----|----|----|----|----|----|----| 　　 三趟结果 　　
 * 04 13 27 38 49 49 55 65 76 97
 */
 
 ---------------------------------
 SortTest
 ---------------------------------
 package cn.itcast;

import java.util.Arrays;

public class SortTest {

	public static void main(String[] args) {
		int[] arr = { 2, 5, 3, 1, 4 };
		System.out.println("排序前：" + Arrays.toString(arr));
		// InsertSort.sort(arr);
		// BubbleSort.sort(arr);
		// SelectionSort.sort(arr);
		// ShellSort.sort(arr);
		// QuickSort.sort(arr);
		// MergeSort.sort(arr);
		// HeapSort.sort(arr);
		System.out.println("排序后：" + Arrays.toString(arr));
	}

	/*
	 * 交换数组中的两个元素
	 */
	public static void swap(int[] data, int i, int j) {
		int temp = data[i];
		data[i] = data[j];
		data[j] = temp;
	}
}
