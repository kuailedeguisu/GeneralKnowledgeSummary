Map
As a student, you can distinguish student by student number
If we know student number, I would like to get Student Object by student number
If we use Collection to do it, we only can store student number and student name in Student Obeject

Map: can store element with (key, value) pair
An object that maps keys to values. A map cannot contain duplicate keys; 
each key can map to at most one value. 

Collection:
	Collection elements are existing An object that maps keys to values.
	Collection subclass Set elements are unique, List elements can be duplicated
	Collection data structure is valid only for element	
Map:
	A map cannot contain duplicate keys; each key can map to at most one value.
	Map elements are paired in key and value, and key is unique, value can be duplicated
	Map data structure is valid only for key, not related to value

HashMap
TreeMap

Map functions:
add function:
	V put?(K key,
		V value) //Associates the specified value with the specified key in this map
				 // If key is stored at first time, return null
				 // If key is not stored at first time, replace original value as new value, and return original value
	void putAll?(Map<? extends K,? extends V> m)// Copies all of the mappings from the specified map to this map 
delete function:
	void clear() // Removes all of the mappings from this map
	V remove?(Object key)// Removes the mapping for a key from this map if it is present
	default boolean remove?(Object key,
                       Object value) // Removes the entry for the specified key only if it is currently mapped to the specified value.
	
judge function
	boolean containsKey?(Object key)     // Returns true if this map contains a mapping for the specified key
	boolean containsValue?(Object value) // Returns true if this map maps one or more keys to the specified value.
	boolean isEmpty()                    // Returns true if this map contains no key-value mappings.
lengh function:
	int size()             // Returns the number of key-value mappings in this map. 
get function:
	Set<Map.Entry<K,V>> entrySet()// Returns a Set view of the mappings contained in this map.
	V get?(Object key)     // Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. 
	Set<K> keySet()        // Returns a Set view of the keys contained in this map.
	Collection<V> values() // Returns a Collection view of the values contained in this map. 
traverse function:

************************************************
HashMap basic functions:
*************************************************
package cn.itcast_01;

import java.util.HashMap;
import java.util.Map;

public class MapBasicFunTest {

	public static void main(String[] args) {
		Map<String, String> strHashMap = new HashMap<String, String>();
		// check put returns
//		System.out.println("put:"+strHashMap.put("wenzhang", "mayili"));
//		System.out.println("put:"+strHashMap.put("wenzhang", "yaodi"));
//		System.out.println("-------");
		
		// add elements
		strHashMap.put("dengchao", "sunli");
		strHashMap.put("huangxiaoming", "yangying");
		strHashMap.put("zhoujielun", "kunling");
		strHashMap.put("liukaiwei", "yangmi");
		System.out.println("map:"+strHashMap);// rewrite toString()
		System.out.println("-------------");
		
		// clear all elements
//		strHashMap.clear();
//		System.out.println("map:"+strHashMap);
		
		// remove element by key
		// return null if not existing element in Map
		strHashMap.remove("huangxiaoming");
		System.out.println("map:"+strHashMap);
		System.out.println("--------------");
		
		// remove element by (key, value)
		// if (key, value) doesn't exist in the Map
		// don't remove the element
		strHashMap.remove("zhoujielun", "sunli");
		System.out.println("map:"+strHashMap);
		strHashMap.remove("zhoujielun", "kunling");
		System.out.println("map:"+strHashMap);
		
		// containsKey and containsValue
		System.out.println("containsKey:"+strHashMap.containsKey("dengchao"));
		System.out.println("containsKey:"+strHashMap.containsKey("zhoujielun"));
		System.out.println("containsValue:"+strHashMap.containsValue("sunli"));
		System.out.println("containsValue:"+strHashMap.containsValue("jiangwenli"));
		
		// isEmpty and size
		System.out.println("isEmpty:"+strHashMap.isEmpty());
		System.out.println("size:"+strHashMap.size());
		
		
	}
}


result:
map:{zhoujielun=kunling, liukaiwei=yangmi, dengchao=sunli, huangxiaoming=yangying}
-------------
map:{zhoujielun=kunling, liukaiwei=yangmi, dengchao=sunli}
--------------
map:{zhoujielun=kunling, liukaiwei=yangmi, dengchao=sunli}
map:{liukaiwei=yangmi, dengchao=sunli}
containsKey:true
containsKey:false
containsValue:true
containsValue:false
isEmpty:false
size:2
*************************************************************
Get value by key, get all keys, get all values
********************************************************
package cn.itcast.get;

import java.sql.Connection;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class HashMapGetTest {

	public static void main(String[] args) {
		Map<String, String> strHashMap = new HashMap<String, String>();
		strHashMap.put("Zhou Jielun", "Kun Ling");
		strHashMap.put("Deng Chao", "Sun Li");
		strHashMap.put("Huang Xiaoming", "Yang Ying");
		strHashMap.put("Chen Xiaochun", "Ying Caier");
		strHashMap.put("Liang Chaowei", "Liu Jialing");
		
		// get
		System.out.println("get:"+strHashMap.get("Zhou Jielun"));
		System.out.println("get:"+strHashMap.get("Liu Dehua")); // return null
		System.out.println("-------------");
		
		// keySet and values
		Set<String> keySet = strHashMap.keySet();
		for (String str : keySet) {
			System.out.println(str);
		}
//		System.out.println("KeySet:"+strHashMap.keySet());		
		System.out.println("--------------------");
		

		Collection<String> strCol = strHashMap.values();
		for (String valueString : strCol) {
			System.out.println(valueString);
		}
//		System.out.println("values:"+strHashMap.values());
		System.out.println("--------------------------");
	}

}


result:
get:Kun Ling
get:null
-------------
Liang Chaowei
Huang Xiaoming
Zhou Jielun
Chen Xiaochun
Deng Chao
--------------------
Liu Jialing
Yang Ying
Kun Ling
Ying Caier
Sun Li
--------------------------
***************************************************
Map traverse:
method 01:
package cn.itcast_03;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class MapTraverseTest {

	public static void main(String[] args) {
		Map<String, String> strHashMap = new HashMap<String, String>();
		strHashMap.put("Zhou Jielun", "Kun Ling");
		strHashMap.put("Deng Chao", "Sun Li");
		strHashMap.put("Huang Xiaoming", "Yang Ying");
		strHashMap.put("Chen Xiaochun", "Ying Caier");
		strHashMap.put("Liang Chaowei", "Liu Jialing");
		
		Set<String> keySet = strHashMap.keySet();
		for (String keyString : keySet) {
			String value = strHashMap.get(keyString);
			System.out.println(keyString+"-"+value);
		}
	}

}


result:
Liang Chaowei-Liu Jialing
Huang Xiaoming-Yang Ying
Zhou Jielun-Kun Ling
Chen Xiaochun-Ying Caier
Deng Chao-Sun Li

*************************************
Map traverse

method 02:
Set<Map.Entry<K,V>> entrySet()
Entry<K,V> is an key value pair Object
Interface Map.Entry<K,V>
K getKey()   // Returns the key corresponding to this entry.
V getValue() // Returns the value corresponding to this entry.

package cn.itcast_03;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class MapTraversetTest02 {

	public static void main(String[] args) {
		Map<String, String> strHashMap = new HashMap<String, String>();
		strHashMap.put("Zhou Jielun", "Kun Ling");
		strHashMap.put("Deng Chao", "Sun Li");
		strHashMap.put("Huang Xiaoming", "Yang Ying");
		strHashMap.put("Chen Xiaochun", "Ying Caier");
		strHashMap.put("Liang Chaowei", "Liu Jialing");
		
		Set<Entry<String, String>> keyValueSet = strHashMap.entrySet();
		for (Entry<String, String> entry : keyValueSet) {
			String keyString = entry.getKey();
			String valueString = entry.getValue();
			System.out.println(keyString + "--------"+ valueString);
		}

	}

}

result:
Liang Chaowei--------Liu Jialing
Huang Xiaoming--------Yang Ying
Zhou Jielun--------Kun Ling
Chen Xiaochun--------Ying Caier
Deng Chao--------Sun Li
****************************************************************
Map: two columns
		traverse: 
			method 1: keySet() to get key Set, get() to get value by key
			method 2: entrySet(), getKey() to get key, getValue() to get value
Collection: one column

HashMap: Implement Class of Interface Map based on Hash table
		Hash Table to guarantee key unique

************************************************
HashMap to keep key unique
package cn.itcast_02;

import java.util.HashMap;
import java.util.Set;

public class HashMapTest01 {

	public static void main(String[] args) {
		HashMap<String, String> strHashMap = new HashMap<String, String>();
		
		strHashMap.put("it001", "mayun");
		strHashMap.put("it002", "mahuateng");
		strHashMap.put("it003", "zhangchaoyang");
		strHashMap.put("it004", "qiubojun");//wps, jinshan
		strHashMap.put("it001", "biergaici");
		
		Set<String> set = strHashMap.keySet();
		
		for (String keyString : set) {
			String value = strHashMap.get(keyString);
			System.out.println(keyString + "------------"+value);
		}
	
	}
}


result:
it004------------qiubojun
it003------------zhangchaoyang
it002------------mahuateng
it001------------biergaici

analysis:
HashMap<String, String>
hash table: based on String hashCode() and equals(), and String has rewritten them
*******************************
HashMap<String, String>

package cn.itcast_02;

import java.util.HashMap;
import java.util.Set;

public class HashMapTest01 {

	public static void main(String[] args) {
		HashMap<String, String> strHashMap = new HashMap<String, String>();
		
		strHashMap.put("it001", "mayun");
		strHashMap.put("it002", "mahuateng");
		strHashMap.put("it003", "zhangchaoyang");
		strHashMap.put("it004", "qiubojun");//wps, jinshan
		strHashMap.put("it001", "biergaici");
		
		Set<String> set = strHashMap.keySet();
		
		for (String keyString : set) {
			String value = strHashMap.get(keyString);
			System.out.println(keyString + "------------"+value);
		}
	
	}
}

result:
it004------------qiubojun
it003------------zhangchaoyang
it002------------mahuateng
it001------------biergaici
*********************************************

HashMap<Integer, String>
package cn.itcast_02;

import java.util.HashMap;
import java.util.Set;

public class HashMapIntegerStringTest {

	public static void main(String[] args) {
		HashMap<Integer, String> intStr = new HashMap<Integer, String>();
		intStr.put(27, "Lin Qingxia");
		intStr.put(29, "Emma");
		intStr.put(30, "Bob");
		intStr.put(35, "Peter");
		
		Set<Integer> set = intStr.keySet();
		
		for (Integer keyString : set) {
			String value = intStr.get(keyString);
			System.out.println(keyString + "------------"+value);
		}

	}

}


result:
35------------Peter
27------------Lin Qingxia
29------------Emma
30------------Bob
****************************************
HashMap<String, Student>

package cn.itcast_02;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class HashMapStringStudentTest {

	public static void main(String[] args) {
		HashMap<String, Student> strStuHashMap = new HashMap<String, Student>();
		Student s1 = new Student("Emma", 20);
		Student s2 = new Student("Peter", 30);
		Student s3 = new Student("Susan", 40);
		Student s4 = new Student("Andy", 50);
		Student s5 = new Student("Sophie", 60);
		
		strStuHashMap.put("s001", s1);
		strStuHashMap.put("s002", s2);
		strStuHashMap.put("s003", s3);
		strStuHashMap.put("s004", s4);
		strStuHashMap.put("s005", s5);
		
		Set<Entry<String, Student>> entrySet = strStuHashMap.entrySet();
		
		for (Entry<String, Student> entry : entrySet) {
			String keyString = entry.getKey();
			Student student = entry.getValue();
			System.out.println(keyString+"----"+student);
		}
	}
}

result:
s004----Student [nameString=Andy, age=50]
s003----Student [nameString=Susan, age=40]
s005----Student [nameString=Sophie, age=60]
s002----Student [nameString=Peter, age=30]
s001----Student [nameString=Emma, age=20]
*********************************************
HashMap<Student, String>

package cn.itcast_02;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class HashMapStringStudentTest3 {

	public static void main(String[] args) {
		HashMap<Student, String> strStuHashMap = new HashMap<Student, String>();
		Student s1 = new Student("Emma", 20);
		Student s2 = new Student("Peter", 30);
		Student s3 = new Student("Susan", 40);
		Student s4 = new Student("Andy", 50);
		Student s5 = new Student("Sophie", 60);
		
		strStuHashMap.put(s1, "s001");
		strStuHashMap.put(s2, "s002");
		strStuHashMap.put(s3, "s003");
		strStuHashMap.put(s4, "s004");
		strStuHashMap.put(s5, "s005");
		
		Set<Entry<Student, String>> entrySet = strStuHashMap.entrySet();
		
		for (Entry<Student, String> entry : entrySet) {
			Student student = entry.getKey();
			String string = entry.getValue();
			System.out.println(student+"----"+string);
		}
	}
}

result:
Student [nameString=Sophie, age=60]----s005
Student [nameString=Emma, age=20]----s001
Student [nameString=Peter, age=30]----s002
Student [nameString=Andy, age=50]----s004
Student [nameString=Susan, age=40]----s003
******************************************************


LinkedHashMap
public class LinkedHashMap<K,V>
extends HashMap<K,V>
implements Map<K,V>

Hash table and linked list implementation of the Map interface,
with predictable iteration order.

hash table to keep key unique
linked list to keep keyboard order(stored order and got order are consistent)
***************************************************
package cn.itcast_01;

import java.util.LinkedHashMap;
import java.util.Map.Entry;
import java.util.Set;

public class LinkedHashMapTest {

	public static void main(String[] args) {
		LinkedHashMap<String, String> strStr = new LinkedHashMap<String, String>();
		strStr.put("Deng Chao", "Sun Li");
		strStr.put("Liang Chaowei", "Liu Jialing");
		strStr.put("Zhou Jielun", "Kun Ling");
		strStr.put("Chen Xiaochun", "Ying caier");
		strStr.put("Zhou Jielun", "Cai Yilin");
		
		Set<Entry<String, String>> entrys = strStr.entrySet();
		for (Entry<String, String> entry : entrys) {
			String keyString = entry.getKey();
			String valueString = entry.getValue();
			System.out.println(keyString+"----"+valueString);
		}
	}
}

result:
Deng Chao----Sun Li
Liang Chaowei----Liu Jialing
Zhou Jielun----Cai Yilin
Chen Xiaochun----Ying caier
***************************************************************


TreeMap
public class TreeMap<K,V>
extends AbstractMap<K,V>
implements NavigableMap<K,V>, Cloneable, Serializable

A Red-Black tree based NavigableMap implementation.
The map is sorted according to the natural ordering of its keys,
or by a Comparator provided at map creation time, depending on which constructor is used.


TreeMap
key is Red-Black tree, which can make key unique and ordered
TreeMap<String, String>
TreeMap<Student, String>

********************************
TreeMap<String, String>
package day18_TreeMapTest;

import java.util.Set;
import java.util.TreeMap;
import java.util.Map.Entry;

public class TreeMapStringStringTest {

	public static void main(String[] args) {
		TreeMap<String, String> strStrTreeMap = new TreeMap<String, String>();
		strStrTreeMap.put("Deng Chao", "Sun Li");
		strStrTreeMap.put("Liang Chaowei", "Liu Jialing");
		strStrTreeMap.put("Zhou Jielun", "Kun Ling");
		strStrTreeMap.put("Chen Xiaochun", "Ying caier");
		strStrTreeMap.put("Zhou Jielun", "Cai Yilin");
		
		Set<String> keys = strStrTreeMap.keySet();
		for (String key : keys) {
			String valueString = strStrTreeMap.get(key);
			System.out.println(key+"----"+valueString);
		}
	}
}

result:
Chen Xiaochun----Ying caier
Deng Chao----Sun Li
Liang Chaowei----Liu Jialing
Zhou Jielun----Cai Yilin

*************************************
TreeMap<Student, String>

Student.java

package day18_TreeMapTest;

public class Student {
	private String nameString;
	private int age;
	
	public Student() {
		super();
	}

	public Student(String nameString, int age) {
		super();
		this.nameString = nameString;
		this.age = age;
	}

	public String getNameString() {
		return nameString;
	}

	public void setNameString(String nameString) {
		this.nameString = nameString;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + age;
		result = prime * result + ((nameString == null) ? 0 : nameString.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Student other = (Student) obj;
		if (age != other.age)
			return false;
		if (nameString == null) {
			if (other.nameString != null)
				return false;
		} else if (!nameString.equals(other.nameString))
			return false;
		return true;
	}

	@Override
	public String toString() {
		return "Student [nameString=" + nameString + ", age=" + age + "]";
	}
	
	
	

}

package day18_TreeMapTest;

import java.util.Comparator;
import java.util.HashMap;
import java.util.Set;
import java.util.TreeMap;
import java.util.Map.Entry;

public class TreeSetStudentStringTest {

	public static void main(String[] args) {
		TreeMap<Student, String> strStuTreeMap = new TreeMap<Student, String>(new Comparator<Student>() {

			public int compare(Student s1, Student s2) {
				int num = s1.getAge() - s2.getAge();
				int num2 = num == 0 ? s1.getNameString().compareTo(s2.getNameString()) : num;
				return num2;
			}
			
		});
		Student s1 = new Student("Emma", 20);
		Student s2 = new Student("Peter", 30);
		Student s3 = new Student("Susan", 40);
		Student s4 = new Student("Andy", 50);
		Student s5 = new Student("Sophie", 60);
		Student s6 = new Student("Anele", 60);
		
		strStuTreeMap.put(s1, "s001");
		strStuTreeMap.put(s2, "s002");
		strStuTreeMap.put(s3, "s003");
		strStuTreeMap.put(s4, "s004");
		strStuTreeMap.put(s5, "s005");
		strStuTreeMap.put(s6, "s006");
		
		Set<Entry<Student, String>> entrySet = strStuTreeMap.entrySet();
		
		for (Entry<Student, String> entry : entrySet) {
			Student student = entry.getKey();
			String string = entry.getValue();
			System.out.println(student+"----"+string);
		}
	}
}



result:
Student [nameString=Emma, age=20]----s001
Student [nameString=Peter, age=30]----s002
Student [nameString=Susan, age=40]----s003
Student [nameString=Andy, age=50]----s004
Student [nameString=Anele, age=60]----s006
Student [nameString=Sophie, age=60]----s005
***********************************************
Compute char count in one String
********************************
package day18_countChar;

import java.util.Scanner;
import java.util.Set;
import java.util.TreeMap;

public class StringCharCountTest02 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("Please enter a String:");
		String string = sc.nextLine();
		char[] charArray = string.toCharArray();
		TreeMap<Character, Integer> tm = new TreeMap<Character, Integer>();

		for (Character character : charArray) {
			Integer i = tm.get(character);// get last time count
			if (i == null) {
				tm.put(character, 1);
			}
			else {
				i++;
				tm.put(character, i);
			}
		}
		
		Set<Character> chSet = tm.keySet();
		StringBuffer sBuffer = new StringBuffer();
		for (Character character : chSet) {
			Integer valueInteger = tm.get(character);
			sBuffer.append(character).append("(").append(valueInteger).append(")").append(" ");
//			System.out.println(character+"("+valueInteger+")");
		}
		
		System.out.println(sBuffer.toString());
	}
}

result:
Please enter a String:
aabbb1111444444444
a(2) 1(4) b(3) 4(9) 
*********************************************

Collection nesting
HashMap nesting
TreeMap

*****************************************
package cn.itcast_01;

import java.util.HashMap;
import java.util.Set;

public class HashMapNestingTest02 {

	public static void main(String[] args) {

		HashMap<String, HashMap<String, Integer>> hm = new HashMap<String, HashMap<String, Integer>>();
		HashMap<String, Integer> jcMap = new HashMap<String, Integer>();
		jcMap.put("Emma", 20);
		jcMap.put("Peter", 23);
		hm.put("jc", jcMap);
		
		HashMap<String, Integer> jyMap = new HashMap<String, Integer>();
		jyMap.put("Bob", 19);
		jyMap.put("John", 18);
		hm.put("jy", jyMap);
		
		Set<String> set = hm.keySet();
		for (String string : set) {
			System.out.println(string);
			HashMap<String, Integer> valueHashMap = hm.get(string);
			Set<String> inKeys = valueHashMap.keySet();
			for (String inKey : inKeys) {
				Integer i = valueHashMap.get(inKey);
				System.out.println("\t"+inKey+"---"+i);
			}
			
		}
		
	}

}

result:
jc
	Peter---23
	Emma---20
jy
	Bob---19
	John---18
**********************************************
day18_2
HashMap nesting
************************************
HashMap<String, ArrayList<String>> 
*********************************************
package cn.itcast_01;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;

public class HashMapArrayListTest {

	public static void main(String[] args) {
		HashMap<String, ArrayList<String>> hm = new HashMap<String, ArrayList<String>>();
		ArrayList<String> strArrayList1 = new ArrayList<String>();
		strArrayList1.add("Lu Bu");
		strArrayList1.add("Cao Cao");
		strArrayList1.add("Zhu Geliang");
		hm.put("SanGuoYanyi", strArrayList1);
		
		ArrayList<String> strArrayList2 = new ArrayList<String>();
		strArrayList2.add("Jia Baoyu");
		strArrayList2.add("Lin Daiyu");
		hm.put("HongLouMeng", strArrayList2);
		
		ArrayList<String> strArrayList3 = new ArrayList<String>();
		strArrayList3.add("Tang Seng");
		strArrayList3.add("Sun Wukong");
		strArrayList3.add("Zhu Bajie");
		strArrayList3.add("Sha Wujing");
		hm.put("XiYouJi", strArrayList3);
		
		Set<String> set = hm.keySet();
		for (String string : set) {
			System.out.println(string);
			ArrayList<String> valueArrayList = hm.get(string);
			
			for (String elem : valueArrayList) {
				System.out.println("\t"+elem);
			}
		}
		

	}

}

Result:
HongLouMeng
	Jia Baoyu
	Lin Daiyu
XiYouJi
	Tang Seng
	Sun Wukong
	Zhu Bajie
	Sha Wujing
SanGuoYanyi
	Lu Bu
	Cao Cao
	Zhu Geliang
***************************************
HashMap<String, ArrayList<HashMap<String, String>>>
*****************************
package cn.itcast_01;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;

public class ArrayListHashMapTest {

	public static void main(String[] args) {
		HashMap<String, ArrayList<HashMap<String, String>>> bigHm = new HashMap<String, ArrayList<HashMap<String, String>>>();
		
		ArrayList<HashMap<String, String>> arrayList1 = new ArrayList<HashMap<String, String>>();
		HashMap<String, String> hm11 =  new HashMap<String, String>();
		hm11.put("Deng Chao", "Sun Li");
		hm11.put("Chen Xiaochun", "Ying Caier");
		arrayList1.add(hm11);
		HashMap<String, String> hm12 =  new HashMap<String, String>();
		hm12.put("Liang Chaowei", "Liu Jialing");
		hm12.put("Wen Zhang", "Ma Yili");
		arrayList1.add(hm12);
		bigHm.put("Celebrity", arrayList1);
		
		ArrayList<HashMap<String, String>> arrayList2 = new ArrayList<HashMap<String, String>>();
		HashMap<String, String> hm21 =  new HashMap<String, String>();
		hm21.put("Xi Jinping", "Peng Liyuan");
		hm21.put("Henry Charles", "Diana Spencer");
		arrayList2.add(hm21);
		HashMap<String, String> hm22 =  new HashMap<String, String>();
		hm22.put("Hu Jintao", "Liu Yongqing");
		hm22.put("Jiang Zemin", "Wang Yeping");
		arrayList2.add(hm22);
		bigHm.put("Political", arrayList2);
		
		ArrayList<HashMap<String, String>> arrayList3 = new ArrayList<HashMap<String, String>>();
		HashMap<String, String> hm31 =  new HashMap<String, String>();
		hm31.put("Yang Zhenning", "Weng Fan");
		hm31.put("Qian Xuesen", "Jiang Ying");
		arrayList3.add(hm31);
		HashMap<String, String> hm32 =  new HashMap<String, String>();
		hm32.put("Ai DiSheng", "A");
		hm32.put("Ai MoSheng", "B");
		arrayList3.add(hm32);
		bigHm.put("Scientist", arrayList3);
		
		Set<String> setCat = bigHm.keySet();
		for (String str : setCat) {
			System.out.println(str);
			ArrayList<HashMap<String, String>> valueArrayList = bigHm.get(str);
			for (HashMap<String, String> hm : valueArrayList) {
				Set<String> set = hm.keySet();
				for (String key : set) {
					String valueString = hm.get(key);
					System.out.println("\t"+key+"--"+valueString);
				}
			}
		}



	}

}

Result:
Celebrity
	Chen Xiaochun--Ying Caier
	Deng Chao--Sun Li
	Liang Chaowei--Liu Jialing
	Wen Zhang--Ma Yili
Scientist
	Qian Xuesen--Jiang Ying
	Yang Zhenning--Weng Fan
	Ai MoSheng--B
	Ai DiSheng--A
Political
	Xi Jinping--Peng Liyuan
	Henry Charles--Diana Spencer
	Hu Jintao--Liu Yongqing
	Jiang Zemin--Wang Yeping
**********************************
ArrayList<HashMap<String, String>>
**************************************************
package cn.itcast_01;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;

public class ArrayListHashMapTest02 {

	public static void main(String[] args) {
		ArrayList<HashMap<String, String>> arrayList = new ArrayList<HashMap<String, String>>();
		
		HashMap<String, String> hm1 = new HashMap<String, String>();
		hm1.put("Zhou Yu", "Xiao Qiao");
		hm1.put("Lv Bu", "Diao Chan");
		arrayList.add(hm1);
		
		HashMap<String, String> hm2 = new HashMap<String, String>();
		hm2.put("Guo Jing", "Huang Rong");
		hm2.put("Yang Guo", "Xiao Longnv");
		arrayList.add(hm2);
		
		HashMap<String, String> hm3 = new HashMap<String, String>();
		hm3.put("Ling Huchong", "Ren Yingying");
		hm3.put("Ling Pingzhi", "Yue Lingshan");
		arrayList.add(hm3);
		
		for (HashMap<String, String> hm: arrayList) {
			System.out.println("---------------------");
			Set<String> set = hm.keySet();
			for (String key : set) {
				String valueString = hm.get(key);
				System.out.println(key+"--"+valueString);
			}
		}

	}

}


Result:
---------------------
Zhou Yu--Xiao Qiao
Lv Bu--Diao Chan
---------------------
Yang Guo--Xiao Longnv
Guo Jing--Huang Rong
---------------------
Ling Pingzhi--Yue Lingshan
Ling Huchong--Ren Yingying
************************************************
1. The difference between HashMap and Hashtable
Hashtable: thread-safe, low efficiency, null key and null value are not permitted
HashMap: thread-unsafe, high efficiency, null key and null value are permitted

public class Hashtable<K,V>
extends Dictionary<K,V>
implements Map<K,V>, Cloneable, Serializable
This class implements a hash table, which maps keys to values.
Any non-null object can be used as a key or as a value.
To successfully store and retrieve objects from a hashtable, 
the objects used as keys must implement the hashCode method and the equals method.

HashMap
public class HashMap<K,V>
extends AbstractMap<K,V>
implements Map<K,V>, Cloneable, Serializable
Hash table based implementation of the Map interface. 
This implementation provides all of the optional map operations,
and permits null values and the null key. 
(The HashMap class is roughly equivalent to Hashtable, 
except that it is unsynchronized and permits nulls.) 
This class makes no guarantees as to the order of the map; 
in particular, it does not guarantee that the order will remain constant over time. 

************************************************
package cn.itcast_01;

import java.util.HashMap;
import java.util.Hashtable;
import java.util.Set;

public class HashtableTest01 {

	public static void main(String[] args) {
		// Hashtable
		Hashtable<String, String> strHashtable = new Hashtable<String, String>();
		strHashtable.put("it001", "Steven Jobs"); // Apple
		strHashtable.put("it002", "Mark Elliot Zuckerberg"); // Facebook
		strHashtable.put("it003", "Bill Gates"); // Microsoft
		strHashtable.put("it004", "Jeff Bezos"); // Amazon
		strHashtable.put("it005", "Warren E. Buffet"); 
		strHashtable.put("it006", "Larry Ellison"); // Oracle
//		strHashtable.put(null, "Larry Ellison"); // java.lang.NullPointerException
//		strHashtable.put("it007", null); // java.lang.NullPointerException
//		strHashtable.put(null, null); // java.lang.NullPointerException
		
		
		Set<String> keySet = strHashtable.keySet();
		
		for (String key : keySet) {
			String value = strHashtable.get(key);
			System.out.println(key+"---"+value);
		}
		
		System.out.println("------------------------");
		// HashMap
		HashMap<String, String> hm = new HashMap<String, String>();
		hm.put("md001", "Taylor Swift");
		hm.put("md002", "BeyoncÈ Giselle Knowles");
		hm.put("md003", "Celine Dion");
		hm.put(null, "A");
		hm.put("B", null);
		hm.put(null, null);
		
		Set<String> keySetHm = hm.keySet();
		
		for (String key : keySetHm) {
			String value = hm.get(key);
			System.out.println(key+"---"+value);
		}
	}
}


result:
it005---Warren E. Buffet
it004---Jeff Bezos
it003---Bill Gates
it002---Mark Elliot Zuckerberg
it001---Steven Jobs
it006---Larry Ellison
------------------------
null---null
md003---Celine Dion
B---null
md001---Taylor Swift
md002---BeyoncÈ Giselle Knowles
************************************************

2. List, Set, Map interfaces are all inheritting subMap interface?
List, Set are not inheritting Map interface, they are inheritting Collection interface
Map interface is the top interface of Map

3. Collections
public class Collections
extends Object

This class consists exclusively of static methods that operate on or return collections. 
It contains polymorphic algorithms that operate on collections, "wrappers", 
which return a new collection backed by a specified collection, 
and a few other odds and ends.
The methods of this class all throw a NullPointerException if the collections 
or class objects provided to them are null. 

Collections: operate Collection, static methods

public static <T> int binarySearch?(List<? extends T> list,
                                   T key,
                                   Comparator<? super T> c) // binary search, return -(maxIndex + 1) if not found
public static <T> int binarySearch?(List<? extends Comparable<? super T>> list,
                                   T key) // return -(maxIndex + 1) if not found
public static <T extends Comparable<? super T>> void sort?(List<T> list) // sort, natural sort by default
public static <T> void sort?(List<T> list,
                            Comparator<? super T> c)
public static <T extends Object & Comparable<? super T>> T max?(Collection<? extends T> coll) // max value
public static <T> T max?(Collection<? extends T> coll,
                        Comparator<? super T> comp)
public static void reverse?(List<?> list) // reverse
public static void shuffle?(List<?> list) // random swap

						
The difference between Collection and Collections
Collection: single column Collection top interface, has sub interface List and Set
Collections: tool Class to operate Collection, has the methods to sort and find Collection

*********************************************************
package cn.itcast_01;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class CollectionsTest01 {

	public static void main(String[] args) {
		List<Integer> list = new ArrayList<Integer>();
		list.add(30);
		list.add(50);
		list.add(40);
		list.add(10);
		list.add(20);
		
		System.out.println("Original list:"+list);
//		Collections.sort(list); // change original list
//		System.out.println("Sorted list:"+list);
//		
//		int index = Collections.binarySearch(list, 20); // not change original list
//		System.out.println("binarySearch index:"+index);
//		
//		int index2 = Collections.binarySearch(list, 100);
//		System.out.println("binarySearch index:"+index2);
//		
//		System.out.println("max:"+Collections.max(list)); // not change original list
		
//		Collections.reverse(list);
//		System.out.println("Reversed list:"+list); // change original list
		
		Collections.shuffle(list);
		System.out.println("Shuffled list:"+list); // change original list

	}

}
******************************************************

Collections
Collections can sort elements of the ArrayList storing base wrapper class,
and can it store custom objects? 

*****************************************
Method 1: 
Student implements Comparable,
then define compareTo method in Student
******************************************
Student.java
package cn.itcast_01;

public class Student implements Comparable<Student> {
	private String nameString;
	private int age;
	
	public Student() {
		super();
	}

	public Student(String nameString, int age) {
		super();
		this.nameString = nameString;
		this.age = age;
	}

	public String getNameString() {
		return nameString;
	}

	public void setNameString(String nameString) {
		this.nameString = nameString;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
//
//	@Override
//	public int hashCode() {
//		final int prime = 31;
//		int result = 1;
//		result = prime * result + age;
//		result = prime * result + ((nameString == null) ? 0 : nameString.hashCode());
//		return result;
//	}
//
//	@Override
//	public boolean equals(Object obj) {
//		if (this == obj)
//			return true;
//		if (obj == null)
//			return false;
//		if (getClass() != obj.getClass())
//			return false;
//		Student other = (Student) obj;
//		if (age != other.age)
//			return false;
//		if (nameString == null) {
//			if (other.nameString != null)
//				return false;
//		} else if (!nameString.equals(other.nameString))
//			return false;
//		return true;
//	}
//
//	@Override
//	public String toString() {
//		return "Student [nameString=" + nameString + ", age=" + age + "]";
//	}

	public int compareTo(Student s) {
		int num = this.getAge() - s.getAge();
		int num2 = num == 0 ? this.getNameString().compareTo(s.getNameString()) : num;
		return num2;
		
	}
	
	
	

}


***************************************
CollectionsStudentTest01.java

package cn.itcast_01;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class CollectionsStudentTest01 {
	public static void main(String[] args) {
		List<Student> list = new ArrayList<Student>();
		Student s1 = new Student("Emma", 20);
		Student s2 = new Student("Peter", 19);
		Student s3 = new Student("Bob", 21);
		Student s4 = new Student("Susan", 22);
		Student s5 = new Student("John", 18);
		Student s6 = new Student("Andy", 18);
		list.add(s1);
		list.add(s2);
		list.add(s3);
		list.add(s4);
		list.add(s5);
		list.add(s6);
		
		for (Student student : list) {
			System.out.println(student.getNameString()+"-----"+student.getAge());
		}
		System.out.println("-------------------");
		
		Collections.sort(list);

		for (Student student : list) {
			System.out.println(student.getNameString()+"-----"+student.getAge());
		}
	}

}

result:
Emma-----20
Peter-----19
Bob-----21
Susan-----22
John-----18
Andy-----18
-------------------
Andy-----18
John-----18
Peter-----19
Emma-----20
Bob-----21
Susan-----22
*********************************************

*****************************************
Method 2: 
Student doesn't implements Comparable
add Comparator Object in Collections.sort method
******************************************
Student.java

package cn.itcast_01;

public class Student {
	private String nameString;
	private int age;
	
	public Student() {
		super();
	}

	public Student(String nameString, int age) {
		super();
		this.nameString = nameString;
		this.age = age;
	}

	public String getNameString() {
		return nameString;
	}

	public void setNameString(String nameString) {
		this.nameString = nameString;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
//
//	@Override
//	public int hashCode() {
//		final int prime = 31;
//		int result = 1;
//		result = prime * result + age;
//		result = prime * result + ((nameString == null) ? 0 : nameString.hashCode());
//		return result;
//	}
//
//	@Override
//	public boolean equals(Object obj) {
//		if (this == obj)
//			return true;
//		if (obj == null)
//			return false;
//		if (getClass() != obj.getClass())
//			return false;
//		Student other = (Student) obj;
//		if (age != other.age)
//			return false;
//		if (nameString == null) {
//			if (other.nameString != null)
//				return false;
//		} else if (!nameString.equals(other.nameString))
//			return false;
//		return true;
//	}
//
//	@Override
//	public String toString() {
//		return "Student [nameString=" + nameString + ", age=" + age + "]";
//	}


	
	
	

}

******************************************************
CollectionsStudentTest01.java


package cn.itcast_01;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class CollectionsStudentTest01 {
	public static void main(String[] args) {
		List<Student> list = new ArrayList<Student>();
		Student s1 = new Student("Emma", 20);
		Student s2 = new Student("Peter", 19);
		Student s3 = new Student("Bob", 21);
		Student s4 = new Student("Susan", 22);
		Student s5 = new Student("John", 18);
		Student s6 = new Student("Andy", 18);
		list.add(s1);
		list.add(s2);
		list.add(s3);
		list.add(s4);
		list.add(s5);
		list.add(s6);
		
		for (Student student : list) {
			System.out.println(student.getNameString()+"-----"+student.getAge());
		}
		System.out.println("-------------------");
		
//		Collections.sort(list);
		Collections.sort(list, new Comparator<Student>() {
			public int compare(Student s1, Student s2) {
				int num = s1.getAge() - s2.getAge();
				int num2 = num == 0 ? s1.getNameString().compareTo(s2.getNameString()) : num;
				return num2;
			}
		});

		for (Student student : list) {
			System.out.println(student.getNameString()+"-----"+student.getAge());
		}
	}

}


result:
Emma-----20
Peter-----19
Bob-----21
Susan-----22
John-----18
Andy-----18
-------------------
Andy-----18
John-----18
Peter-----19
Emma-----20
Bob-----21
Susan-----22
**************************************************
Fight the Landlord:

********************************************
package cn.itcast_01;

import java.util.ArrayList;
import java.util.Collections;

public class PokerDemo {

	public static void main(String[] args) {
		ArrayList<String> strArrayList = new ArrayList<String>();
//		String[] colorsStrings = {"Hearts", "Spades", "Diamonds", "Clubs"};
		String[] colorsStrings = {"?", "?", "?", "?"};
		String[] numbersStrings = {"A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J","Q", "K"};
		
		// Put all pokers into ArrayList
		for (String color : colorsStrings) {
			for (String number : numbersStrings) {
				strArrayList.add(color.concat(number));
			}
		}
		
		strArrayList.add("BK");
		strArrayList.add("SK");
		
		// Shuffle the pokers
		Collections.shuffle(strArrayList);
		
		// Send the pokers
		ArrayList<String> lingQingXiaArrayList = new ArrayList<String>();
		ArrayList<String> caoCaoArrayList = new ArrayList<String>();
		ArrayList<String> zhuGeLiangArrayList = new ArrayList<String>();
		ArrayList<String> diPaiArrayList = new ArrayList<String>();
		
		for (int i=0; i< strArrayList.size(); ++i) {
			// Leave two hole cards
			if (i >= strArrayList.size() - 3) {
				diPaiArrayList.add(strArrayList.get(i));
			}
			if (i%3 == 0) {
				lingQingXiaArrayList.add(strArrayList.get(i));
			} else if (i%3 == 1) {
				caoCaoArrayList.add(strArrayList.get(i));
			} else if (i%3 == 2) {
				zhuGeLiangArrayList.add(strArrayList.get(i));
			}
		}
		
		
		// See poker
		lookPoker("Lin Qingxia", lingQingXiaArrayList);
		lookPoker("Cao Cao", caoCaoArrayList);
		lookPoker("Zhu Geliang", zhuGeLiangArrayList);
		lookPoker("DiPai", diPaiArrayList);
	}
	
	public static void lookPoker(String name, ArrayList<String> array) {
		System.out.println(name+"'s poker is:");
		for (String s : array) {
			System.out.print(s+" ");
		}
		System.out.println();
	}

}


result:
Lin Qingxia's poker is:
?6 ?7 ?3 ?J ?2 ?7 ?8 ?8 ?9 ?4 ?7 ?10 ?J ?5 ?3 ?J ?9 ?10 
Cao Cao's poker is:
?7 ?A ?5 ?4 ?J ?A BK ?5 ?5 ?8 ?2 ?6 ?3 ?Q ?A ?8 ?6 ?6 
Zhu Geliang's poker is:
?4 ?K ?Q ?9 ?K ?3 ?10 ?A ?Q ?Q ?2 ?10 ?K SK ?4 ?2 ?9 ?K 
DiPai's poker is:
?10 ?6 ?K
*********************************************************
Sort pokers:

HashMap
key                  value
0                     ?3
1					  ?3
2                     ?3
3                     ?3
4                     ?4
5					  ?4
6                     ?4
7                     ?4
8
...                  ...
52                    SK
53                    BK

ArrayList to be used in Shuffling cards
0
1
2
3
...
52
53

Send cards:
TreeSet(key ordered automatically)
0,1,...,53

See cards
get value by key


********************************
package cn.itcast_01;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.TreeSet;

public class PokerDemo2 {

	public static void main(String[] args) {
		HashMap<Integer, String> hm = new HashMap<Integer, String>();
		ArrayList<Integer> intArr = new ArrayList<Integer>();
		
		String[] colorsStrings = {"?", "?", "?", "?"};
		String[] numbersStrings = {"3", "4", "5", "6", "7", "8", "9", "10", "J","Q", "K", "A", "2"};
		
		int index = 0;
		
		// Put pokers
		for (String numberString : numbersStrings) {
			for (String colorString : colorsStrings) {
				hm.put(index, colorString.concat(numberString));
				intArr.add(index);
				index++;
			}
 		}
		
		hm.put(index, "SK");
		intArr.add(index);
		index++;
		hm.put(index, "BK");
		intArr.add(index);
		
		// Shuffle pokers
		Collections.shuffle(intArr);
		
		TreeSet<Integer> linQingXiaIntTreeSet = new TreeSet<Integer>();
		TreeSet<Integer> fengQingYangIntTreeSet = new TreeSet<Integer>();
		TreeSet<Integer> caoCaoIntTreeSet = new TreeSet<Integer>();
		TreeSet<Integer> diPaiTreeSet = new TreeSet<Integer>();
		
		// Send pokers
		for (int i=0; i<intArr.size(); ++i) {
			if (i >= intArr.size() - 3) {
				diPaiTreeSet.add(intArr.get(i));
			} else if (i%3 == 0) {
				linQingXiaIntTreeSet.add(intArr.get(i));
			} else if (i%3 == 1) {
				fengQingYangIntTreeSet.add(intArr.get(i));
				
			} else if (i%3 == 2) {
				caoCaoIntTreeSet.add(intArr.get(i));
			}
		}
		
		// See pokers
		lookPoker("Lin Qingxia", linQingXiaIntTreeSet, hm);
		lookPoker("Feng Qingyang", fengQingYangIntTreeSet, hm);
		lookPoker("Cao cao", caoCaoIntTreeSet, hm);
		lookPoker("Di Pai", diPaiTreeSet, hm);
		
		
	}
	
	public static void lookPoker(String name, TreeSet<Integer> intTreeSet, HashMap<Integer, String> hm) {
		System.out.println(name+"'s pokers are:");
		for (Integer keyInteger : intTreeSet) {
			String valueString = hm.get(keyInteger);
			System.out.print(valueString+" ");
		}
		System.out.println();
	}
}

result:
Lin Qingxia's pokers are:
?3 ?4 ?4 ?5 ?5 ?5 ?9 ?10 ?10 ?J ?Q ?Q ?K ?K ?A ?A ?2 
Feng Qingyang's pokers are:
?3 ?6 ?6 ?7 ?7 ?8 ?9 ?10 ?Q ?Q ?K ?A ?A ?2 ?2 ?2 BK 
Cao cao's pokers are:
?3 ?4 ?4 ?5 ?6 ?6 ?7 ?8 ?8 ?9 ?9 ?10 ?J ?J ?J ?K SK 
Di Pai's pokers are:
?3 ?7 ?8 
********************************************
Summary:
Map
	Map definition: (key, value), key is unique
	Map: (key, value)
	Collection: single column
		List: duplicated
		Set: unique
	Map functions:
		add
		delete
		judge
		get
		length
	Map traverse
		key to find value: Map.keySet()+Map.get()
			HashMap<String, String> hm = new HashMap<String, String>();
			hm.put("it001", "A");
			hm.put("it002", "B");
			hm.put("it003", "C");
			Set<String> set = hm.keySet();
			for (String key : set) {
				String value = hm.get(key);
				System.out.println(key+"---"+value);
			}
		(key,value) to find key and value: Map.entrySet(), Entry.getKey(), Entry.getValue()
			HashMap<String, String> hm = new HashMap<String, String>();
			hm.put("it001", "A");
			hm.put("it002", "B");
			hm.put("it003", "C");
			HashMap<Entry<String, String>> entrys = hm.entrySet();
			for (Entry<String, String> entry : entrys) {
				String key = entry.getKey();
				String value = entry.getValue();
				System.out.println(key+"-------"+value);
			}
	HashMap:
		HashMap<String, String>
		HashMap<Integer, String>
		HashMap<String, Student>
		HashMap<Student, String>
	Map:
	TreeMap:
		TreeMap<String, String>
		TreeMap<String, Student>
	compute each char count in one String
	HashMap<HashMap>
	HashMap<ArrayList>
	ArrayList<HashMap>
	multiple levels nesting
Collections
	Differences:
		Collection: interface, List and Set
		Collections: tool Class to operate Collection, static methods
	sort
	binarySearch
	reverse
	shuffle
	ArrayList to store custom Classes
	fight landLord
