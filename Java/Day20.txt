Recursion: method definition calls method itself
public void show(int n) {
	if (n == 0) {
		System.exit(0);
	}
	System.out.println(n);
	show(--n);
}
method calls method itself: method nesting instead of recursion


Notice:
	A: Recursion should have exit otherwise, it is dead loop
	B: Recursion times shouldn't be too much, otherwise memory overflow
	C: Constructor method shouldn't be recursion
	
Recursion thought:
	Decomposition method: 
	Combination method: 

*************************************
Requirement: compute factorial for one integer n-1
method:
	A: loop
	B: Recursion

package day20_Recursion;

import java.util.Scanner;

public class FactorialTest {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		long result = -1;
		System.out.println("Please enter an integer[more than 2]:");
		int n = sc.nextInt();
		if (n <=0) {
			System.out.println("You entered wrong integer");
		} else {
//			result = factorial(n);
			result = factorial2(n);
		}

		System.out.println(result);

	}
	
	public static long factorial(int n) {
		long jc = 1;
		for (int i = 2; i <= n; ++i) {
			jc *= i;
		}
		
		return jc;
	}
	
	public static long factorial2(int n) {
		if (n == 1) {
			return 1;
		}
		
		return factorial2(n-1) * n;
	}

}



result:
Please enter an integer[more than 2]:
5
120
**********************************************
Problems:
1-Fibonacci Numbers
2-The name of the file that specifies the end of the suffix name 
  in the recursive traversal directory 
3-Recursive deletion of directories with content 

****************************************
1-Fibonacci Numbers

package cn.itcast_02;

import java.util.Scanner;

public class FibonacciTest {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("Please enter an integer(more than 2):");
		int n = sc.nextInt();
		if (n < 1) {
			System.out.println("You entered wrong integer!");
		} else {

//			System.out.println(fibonacci(n));
//			System.out.println(fibonacci2(n));
			System.out.println(fibonacci3(n));
		}
	}
	
	// method 1: variable change
	public static int fibonacci(int n) {
		int a = 1;
		int b = 1;
		
		for (int x = 0; x < n - 1; ++x) {
			int tmp = a;
			a = b;
			b = tmp + b;
		}
		
		return b;
	}
	

	// method 2 : array
	public static int fibonacci2(int n) {
		if (n == 1 || n == 2) {
			return 1;
		}
		
		int[] arr = new int[n];
		arr[0] = 1;
		arr[1] = 1;
		for (int i=2; i<arr.length; ++i) {
			arr[i] = arr[i-1] + arr[i-2];
		}
		
		return arr[n-1];
	}
	
	// method 3 : recursion 
	public static long fibonacci3(int n) {
		if (n == 1 || n == 2) {
			return 1;
		} else {
			return fibonacci2(n - 2) + fibonacci2(n - 1);
		}
	}
}


result:
Please enter an integer(more than 2):
10
55
************************************************************
2-The name of the file that specifies the end of the suffix name 
  in the recursive traversal directory (absolute directory)

import java.io.File;

public class TraverseFilesEndsWithTest {

	public static void main(String[] args) {
		File sourceFolder = new File("c:\\develop");
		getAllFilePaths(sourceFolder);
		

	}
	
	public static void getAllFilePaths(File dir) {
		File[] files = dir.listFiles();
		
		for (File file : files) {
			if (file.isDirectory()) {
				getAllFilePaths(file);
			} else {
				if (file.getName().endsWith(".java")) {
					System.out.println(file.getAbsolutePath());
				}
			}
		}
		
	}
}

result:
c:\develop\code\Outer.java
...............
*********************************************************
3-Recursive deletion of directories with content 

package cn.itcast_03;

import java.io.File;

public class RecursionDeleteDirWithContentTest {

	public static void main(String[] args) {
		File sourceFolder = new File("c:\\demo");
		deleteDirWithContent(sourceFolder);


	}
	
	public static void deleteDirWithContent(File sourceFolder) {
		File[] files = sourceFolder.listFiles();
		
		for (File file : files) {
			if (file.isDirectory()) {
				deleteDirWithContent(file);
			} else {
				System.out.println(file.getName()+"----"+file.delete());
			}
		}
		
		System.out.println(sourceFolder.getName() + "---------"+sourceFolder.delete());
	}

}


result:
a.txt----true
test2---------true
test1---------true
test---------true
demo---------true
***********************************************
Day20_1.txt
JAVA IO Stream kinds：
Stream direction：
	Input stream：  Read data
	Output stream：Write data
Data type：
	byte stream：powerful
		Byte input stream :    InputStream
		Byte output stream:   OutputStream
	char stream：convenient to operate text data(easy to read)
		char input stream:       Reader
		char output stream:  Writer

InputStream:      abstract base Class of input stream
OutputStream：abstract base Class of output stream

FileOutputStream
FileInputStream

Byte stream comes before char stream
Each subclass is sufixed with base class
XxxOutputStream
XxxInputStream
XxxReader
XxxWriter

FileOutputStream
public class FileOutputStream
extends OutputStream
A file output stream is an output stream for writing data to a File or to a FileDescriptor. 


public FileOutputStream​(String name)
                 throws FileNotFoundException
public FileOutputStream​(File file,
                        boolean append)
                 throws FileNotFoundException

FileOutputStream: 
	create file by calling system method
      create File Object
	File points to the file

Byte output Stream steps:
	A: create Byte output Stream Object
	B: write data
	C: close Byte output Stream to release resource

FileOutputStream
public void write (byte[] b) throws IOException.                             // write a byte array
public void write (byte[] b, int off, int len) throws IOException.    // write a part of a byte array
public void write (int b) throws IOException                                   // write a byte

***********************************************
package cn.itcast_01;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

public class FileOutputStreamTest {

	public static void main(String[] args) throws IOException {
		// method 1 
		File file = new File("fos.txt");
		FileOutputStream fos = new FileOutputStream(file);
		
		// Write data into file
		fos.write("Hello World!".getBytes());
		fos.write("How old are you?".getBytes());
		fos.write("Beautiful girl".getBytes(), 0, 10);
		
		// release resource, close Stream Object, make it rubbish so that it can be collected
		fos.close();
		
		// method 2
		FileOutputStream fos2 = new FileOutputStream("fos2.txt");
		
		// Write data into file
		fos2.write(97); // 'a'
		fos2.write(57); // '9'
		fos2.write(55); // '7'
		fos2.write("Big World".getBytes(), 4, 5);
		byte[] bysBytes = {97, 98, 99, 100};
		fos2.write(bysBytes);
		fos2.write(bysBytes, 1, 3);
		
		// release resource, close Stream Object
		fos2.close();
	}
}

Fox.txt
Hello World!How old are you?Beautiful 

Fox2.txt
a97Worldabcdbcd

*****************************************************************
FileOutputStream wrap and append:
Wrap
	Windows: \r\n
	Linux: \n
	Mac: \r
Some advanced text editor will be compatible for “\r” or “\n”


Append: depend on FileOutputStream Constructor method
public FileOutputStream​(File file,
                        boolean append)
                 throws FileNotFoundException
public FileOutputStream​(String name,
                        boolean append)
                 throws FileNotFoundException

*******************************************************************
package cn.itcast_02;

import java.io.FileOutputStream;
import java.io.IOException;

public class FileOutputStreamWrapTest {

	public static void main(String[] args) throws IOException {
		FileOutputStream fos = new FileOutputStream("fos3.txt", true);
		for (int i=0; i<10; ++i) {
			fos.write(("Hello"+i).getBytes());
			fos.write("\r".getBytes());		
		}
	}
}

Fos.txt
When you run the program once, the content will be appended
**************************************************************************






  

